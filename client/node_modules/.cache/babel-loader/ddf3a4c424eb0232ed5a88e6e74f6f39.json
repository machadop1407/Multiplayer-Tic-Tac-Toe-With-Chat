{"ast":null,"code":"import React, { useMemo } from 'react';\nimport { useMessageContext } from '../../context/MessageContext';\nimport { isDate, isDayOrMoment, isNumberOrString, useTranslationContext } from '../../context/TranslationContext';\nexport var defaultTimestampFormat = 'h:mmA';\nexport var notValidDateWarning = 'MessageTimestamp was called without a message, or message has invalid created_at date.';\nexport var noParsingFunctionWarning = 'MessageTimestamp was called but there is no datetime parsing function available';\n\nfunction getDateString(messageCreatedAt, formatDate, calendar, tDateTimeParser, format) {\n  if (!messageCreatedAt || !Date.parse(messageCreatedAt)) {\n    console.warn(notValidDateWarning);\n    return null;\n  }\n\n  if (typeof formatDate === 'function') {\n    return formatDate(new Date(messageCreatedAt));\n  }\n\n  if (!tDateTimeParser) {\n    console.warn(noParsingFunctionWarning);\n    return null;\n  }\n\n  var parsedTime = tDateTimeParser(messageCreatedAt);\n\n  if (isDayOrMoment(parsedTime)) {\n    /**\n     * parsedTime.calendar is guaranteed on the type but is only\n     * available when a user calls dayjs.extend(calendar)\n     */\n    return calendar && parsedTime.calendar ? parsedTime.calendar() : parsedTime.format(format);\n  }\n\n  if (isDate(parsedTime)) {\n    return parsedTime.toDateString();\n  }\n\n  if (isNumberOrString(parsedTime)) {\n    return parsedTime;\n  }\n\n  return null;\n}\n\nvar UnMemoizedMessageTimestamp = function (props) {\n  var _a = props.calendar,\n      calendar = _a === void 0 ? false : _a,\n      _b = props.customClass,\n      customClass = _b === void 0 ? '' : _b,\n      _c = props.format,\n      format = _c === void 0 ? defaultTimestampFormat : _c,\n      propMessage = props.message;\n\n  var _d = useMessageContext('MessageTimestamp'),\n      formatDate = _d.formatDate,\n      contextMessage = _d.message;\n\n  var tDateTimeParser = useTranslationContext('MessageTimestamp').tDateTimeParser;\n  var message = propMessage || contextMessage;\n  var createdAt = message.created_at;\n  var when = useMemo(function () {\n    return getDateString(createdAt, formatDate, calendar, tDateTimeParser, format);\n  }, [formatDate, calendar, tDateTimeParser, format, createdAt]);\n  if (!when) return null;\n  return React.createElement(\"time\", {\n    className: customClass,\n    dateTime: createdAt,\n    title: createdAt\n  }, when);\n};\n\nexport var MessageTimestamp = React.memo(UnMemoizedMessageTimestamp);","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/stream-chat-react/dist/components/Message/MessageTimestamp.js"],"names":["React","useMemo","useMessageContext","isDate","isDayOrMoment","isNumberOrString","useTranslationContext","defaultTimestampFormat","notValidDateWarning","noParsingFunctionWarning","getDateString","messageCreatedAt","formatDate","calendar","tDateTimeParser","format","Date","parse","console","warn","parsedTime","toDateString","UnMemoizedMessageTimestamp","props","_a","_b","customClass","_c","propMessage","message","_d","contextMessage","createdAt","created_at","when","createElement","className","dateTime","title","MessageTimestamp","memo"],"mappings":"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","sourcesContent":["import React, { useMemo } from 'react';\nimport { useMessageContext } from '../../context/MessageContext';\nimport { isDate, isDayOrMoment, isNumberOrString, useTranslationContext, } from '../../context/TranslationContext';\nexport var defaultTimestampFormat = 'h:mmA';\nexport var notValidDateWarning = 'MessageTimestamp was called without a message, or message has invalid created_at date.';\nexport var noParsingFunctionWarning = 'MessageTimestamp was called but there is no datetime parsing function available';\nfunction getDateString(messageCreatedAt, formatDate, calendar, tDateTimeParser, format) {\n    if (!messageCreatedAt || !Date.parse(messageCreatedAt)) {\n        console.warn(notValidDateWarning);\n        return null;\n    }\n    if (typeof formatDate === 'function') {\n        return formatDate(new Date(messageCreatedAt));\n    }\n    if (!tDateTimeParser) {\n        console.warn(noParsingFunctionWarning);\n        return null;\n    }\n    var parsedTime = tDateTimeParser(messageCreatedAt);\n    if (isDayOrMoment(parsedTime)) {\n        /**\n         * parsedTime.calendar is guaranteed on the type but is only\n         * available when a user calls dayjs.extend(calendar)\n         */\n        return calendar && parsedTime.calendar ? parsedTime.calendar() : parsedTime.format(format);\n    }\n    if (isDate(parsedTime)) {\n        return parsedTime.toDateString();\n    }\n    if (isNumberOrString(parsedTime)) {\n        return parsedTime;\n    }\n    return null;\n}\nvar UnMemoizedMessageTimestamp = function (props) {\n    var _a = props.calendar, calendar = _a === void 0 ? false : _a, _b = props.customClass, customClass = _b === void 0 ? '' : _b, _c = props.format, format = _c === void 0 ? defaultTimestampFormat : _c, propMessage = props.message;\n    var _d = useMessageContext('MessageTimestamp'), formatDate = _d.formatDate, contextMessage = _d.message;\n    var tDateTimeParser = useTranslationContext('MessageTimestamp').tDateTimeParser;\n    var message = propMessage || contextMessage;\n    var createdAt = message.created_at;\n    var when = useMemo(function () { return getDateString(createdAt, formatDate, calendar, tDateTimeParser, format); }, [formatDate, calendar, tDateTimeParser, format, createdAt]);\n    if (!when)\n        return null;\n    return (React.createElement(\"time\", { className: customClass, dateTime: createdAt, title: createdAt }, when));\n};\nexport var MessageTimestamp = React.memo(UnMemoizedMessageTimestamp);\n"]},"metadata":{},"sourceType":"module"}