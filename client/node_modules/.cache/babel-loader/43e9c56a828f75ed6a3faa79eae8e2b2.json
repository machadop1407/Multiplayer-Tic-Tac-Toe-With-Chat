{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.stateify = exports.TokenState = exports.CharacterState = undefined;\n\nvar _class = require('../utils/class');\n\nfunction createStateClass() {\n  return function (tClass) {\n    this.j = [];\n    this.T = tClass || null;\n  };\n}\n/**\n\tA simple state machine that can emit token classes\n\n\tThe `j` property in this class refers to state jumps. It's a\n\tmultidimensional array where for each element:\n\n\t* index [0] is a symbol or class of symbols to transition to.\n\t* index [1] is a State instance which matches\n\n\tThe type of symbol will depend on the target implementation for this class.\n\tIn Linkify, we have a two-stage scanner. Each stage uses this state machine\n\tbut with a slighly different (polymorphic) implementation.\n\n\tThe `T` property refers to the token class.\n\n\tTODO: Can the `on` and `next` methods be combined?\n\n\t@class BaseState\n*/\n\n\nvar BaseState = createStateClass();\nBaseState.prototype = {\n  defaultTransition: false,\n\n  /**\n  \t@method constructor\n  \t@param {Class} tClass Pass in the kind of token to emit if there are\n  \t\tno jumps after this state and the state is accepting.\n  */\n\n  /**\n  \tOn the given symbol(s), this machine should go to the given state\n  \t\t@method on\n  \t@param {Array|Mixed} symbol\n  \t@param {BaseState} state Note that the type of this state should be the\n  \t\tsame as the current instance (i.e., don't pass in a different\n  \t\tsubclass)\n  */\n  on: function on(symbol, state) {\n    if (symbol instanceof Array) {\n      for (var i = 0; i < symbol.length; i++) {\n        this.j.push([symbol[i], state]);\n      }\n\n      return this;\n    }\n\n    this.j.push([symbol, state]);\n    return this;\n  },\n\n  /**\n  \tGiven the next item, returns next state for that item\n  \t@method next\n  \t@param {Mixed} item Should be an instance of the symbols handled by\n  \t\tthis particular machine.\n  \t@return {State} state Returns false if no jumps are available\n  */\n  next: function next(item) {\n    for (var i = 0; i < this.j.length; i++) {\n      var jump = this.j[i];\n      var symbol = jump[0]; // Next item to check for\n\n      var state = jump[1]; // State to jump to if items match\n      // compare item with symbol\n\n      if (this.test(item, symbol)) {\n        return state;\n      }\n    } // Nowhere left to jump!\n\n\n    return this.defaultTransition;\n  },\n\n  /**\n  \tDoes this state accept?\n  \t`true` only of `this.T` exists\n  \t\t@method accepts\n  \t@return {Boolean}\n  */\n  accepts: function accepts() {\n    return !!this.T;\n  },\n\n  /**\n  \tDetermine whether a given item \"symbolizes\" the symbol, where symbol is\n  \ta class of items handled by this state machine.\n  \t\tThis method should be overriden in extended classes.\n  \t\t@method test\n  \t@param {Mixed} item Does this item match the given symbol?\n  \t@param {Mixed} symbol\n  \t@return {Boolean}\n  */\n  test: function test(item, symbol) {\n    return item === symbol;\n  },\n\n  /**\n  \tEmit the token for this State (just return it in this case)\n  \tIf this emits a token, this instance is an accepting state\n  \t@method emit\n  \t@return {Class} T\n  */\n  emit: function emit() {\n    return this.T;\n  }\n};\n/**\n\tState machine for string-based input\n\n\t@class CharacterState\n\t@extends BaseState\n*/\n\nvar CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {\n  /**\n  \tDoes the given character match the given character or regular\n  \texpression?\n  \t\t@method test\n  \t@param {String} char\n  \t@param {String|RegExp} charOrRegExp\n  \t@return {Boolean}\n  */\n  test: function test(character, charOrRegExp) {\n    return character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);\n  }\n});\n/**\n\tState machine for input in the form of TextTokens\n\n\t@class TokenState\n\t@extends BaseState\n*/\n\nvar TokenState = (0, _class.inherits)(BaseState, createStateClass(), {\n  /**\n   * Similar to `on`, but returns the state the results in the transition from\n   * the given item\n   * @method jump\n   * @param {Mixed} item\n   * @param {Token} [token]\n   * @return state\n   */\n  jump: function jump(token) {\n    var tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var state = this.next(new token('')); // dummy temp token\n\n    if (state === this.defaultTransition) {\n      // Make a new state!\n      state = new this.constructor(tClass);\n      this.on(token, state);\n    } else if (tClass) {\n      state.T = tClass;\n    }\n\n    return state;\n  },\n\n  /**\n  \tIs the given token an instance of the given token class?\n  \t\t@method test\n  \t@param {TextToken} token\n  \t@param {Class} tokenClass\n  \t@return {Boolean}\n  */\n  test: function test(token, tokenClass) {\n    return token instanceof tokenClass;\n  }\n});\n/**\n\tGiven a non-empty target string, generates states (if required) for each\n\tconsecutive substring of characters in str starting from the beginning of\n\tthe string. The final state will have a special value, as specified in\n\toptions. All other \"in between\" substrings will have a default end state.\n\n\tThis turns the state machine into a Trie-like data structure (rather than a\n\tintelligently-designed DFA).\n\n\tNote that I haven't really tried these with any strings other than\n\tDOMAIN.\n\n\t@param {String} str\n\t@param {CharacterState} start State to jump from the first character\n\t@param {Class} endToken Token class to emit when the given string has been\n\t\tmatched and no more jumps exist.\n\t@param {Class} defaultToken \"Filler token\", or which token type to emit when\n\t\twe don't have a full match\n\t@return {Array} list of newly-created states\n*/\n\nfunction stateify(str, start, endToken, defaultToken) {\n  var i = 0,\n      len = str.length,\n      state = start,\n      newStates = [],\n      nextState = void 0; // Find the next state without a jump to the next character\n\n  while (i < len && (nextState = state.next(str[i]))) {\n    state = nextState;\n    i++;\n  }\n\n  if (i >= len) {\n    return [];\n  } // no new tokens were added\n\n\n  while (i < len - 1) {\n    nextState = new CharacterState(defaultToken);\n    newStates.push(nextState);\n    state.on(str[i], nextState);\n    state = nextState;\n    i++;\n  }\n\n  nextState = new CharacterState(endToken);\n  newStates.push(nextState);\n  state.on(str[len - 1], nextState);\n  return newStates;\n}\n\nexports.CharacterState = CharacterState;\nexports.TokenState = TokenState;\nexports.stateify = stateify;","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/linkifyjs/lib/linkify/core/state.js"],"names":["exports","__esModule","stateify","TokenState","CharacterState","undefined","_class","require","createStateClass","tClass","j","T","BaseState","prototype","defaultTransition","on","symbol","state","Array","i","length","push","next","item","jump","test","accepts","emit","inherits","character","charOrRegExp","RegExp","token","arguments","constructor","tokenClass","str","start","endToken","defaultToken","len","newStates","nextState"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.stateify = exports.TokenState = exports.CharacterState = undefined;\n\nvar _class = require('../utils/class');\n\nfunction createStateClass() {\n\treturn function (tClass) {\n\t\tthis.j = [];\n\t\tthis.T = tClass || null;\n\t};\n}\n\n/**\n\tA simple state machine that can emit token classes\n\n\tThe `j` property in this class refers to state jumps. It's a\n\tmultidimensional array where for each element:\n\n\t* index [0] is a symbol or class of symbols to transition to.\n\t* index [1] is a State instance which matches\n\n\tThe type of symbol will depend on the target implementation for this class.\n\tIn Linkify, we have a two-stage scanner. Each stage uses this state machine\n\tbut with a slighly different (polymorphic) implementation.\n\n\tThe `T` property refers to the token class.\n\n\tTODO: Can the `on` and `next` methods be combined?\n\n\t@class BaseState\n*/\nvar BaseState = createStateClass();\nBaseState.prototype = {\n\tdefaultTransition: false,\n\n\t/**\n \t@method constructor\n \t@param {Class} tClass Pass in the kind of token to emit if there are\n \t\tno jumps after this state and the state is accepting.\n */\n\n\t/**\n \tOn the given symbol(s), this machine should go to the given state\n \t\t@method on\n \t@param {Array|Mixed} symbol\n \t@param {BaseState} state Note that the type of this state should be the\n \t\tsame as the current instance (i.e., don't pass in a different\n \t\tsubclass)\n */\n\ton: function on(symbol, state) {\n\t\tif (symbol instanceof Array) {\n\t\t\tfor (var i = 0; i < symbol.length; i++) {\n\t\t\t\tthis.j.push([symbol[i], state]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tthis.j.push([symbol, state]);\n\t\treturn this;\n\t},\n\n\n\t/**\n \tGiven the next item, returns next state for that item\n \t@method next\n \t@param {Mixed} item Should be an instance of the symbols handled by\n \t\tthis particular machine.\n \t@return {State} state Returns false if no jumps are available\n */\n\tnext: function next(item) {\n\t\tfor (var i = 0; i < this.j.length; i++) {\n\t\t\tvar jump = this.j[i];\n\t\t\tvar symbol = jump[0]; // Next item to check for\n\t\t\tvar state = jump[1]; // State to jump to if items match\n\n\t\t\t// compare item with symbol\n\t\t\tif (this.test(item, symbol)) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\n\t\t// Nowhere left to jump!\n\t\treturn this.defaultTransition;\n\t},\n\n\n\t/**\n \tDoes this state accept?\n \t`true` only of `this.T` exists\n \t\t@method accepts\n \t@return {Boolean}\n */\n\taccepts: function accepts() {\n\t\treturn !!this.T;\n\t},\n\n\n\t/**\n \tDetermine whether a given item \"symbolizes\" the symbol, where symbol is\n \ta class of items handled by this state machine.\n \t\tThis method should be overriden in extended classes.\n \t\t@method test\n \t@param {Mixed} item Does this item match the given symbol?\n \t@param {Mixed} symbol\n \t@return {Boolean}\n */\n\ttest: function test(item, symbol) {\n\t\treturn item === symbol;\n\t},\n\n\n\t/**\n \tEmit the token for this State (just return it in this case)\n \tIf this emits a token, this instance is an accepting state\n \t@method emit\n \t@return {Class} T\n */\n\temit: function emit() {\n\t\treturn this.T;\n\t}\n};\n\n/**\n\tState machine for string-based input\n\n\t@class CharacterState\n\t@extends BaseState\n*/\nvar CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {\n\t/**\n \tDoes the given character match the given character or regular\n \texpression?\n \t\t@method test\n \t@param {String} char\n \t@param {String|RegExp} charOrRegExp\n \t@return {Boolean}\n */\n\ttest: function test(character, charOrRegExp) {\n\t\treturn character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);\n\t}\n});\n\n/**\n\tState machine for input in the form of TextTokens\n\n\t@class TokenState\n\t@extends BaseState\n*/\nvar TokenState = (0, _class.inherits)(BaseState, createStateClass(), {\n\n\t/**\n  * Similar to `on`, but returns the state the results in the transition from\n  * the given item\n  * @method jump\n  * @param {Mixed} item\n  * @param {Token} [token]\n  * @return state\n  */\n\tjump: function jump(token) {\n\t\tvar tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\tvar state = this.next(new token('')); // dummy temp token\n\t\tif (state === this.defaultTransition) {\n\t\t\t// Make a new state!\n\t\t\tstate = new this.constructor(tClass);\n\t\t\tthis.on(token, state);\n\t\t} else if (tClass) {\n\t\t\tstate.T = tClass;\n\t\t}\n\t\treturn state;\n\t},\n\n\n\t/**\n \tIs the given token an instance of the given token class?\n \t\t@method test\n \t@param {TextToken} token\n \t@param {Class} tokenClass\n \t@return {Boolean}\n */\n\ttest: function test(token, tokenClass) {\n\t\treturn token instanceof tokenClass;\n\t}\n});\n\n/**\n\tGiven a non-empty target string, generates states (if required) for each\n\tconsecutive substring of characters in str starting from the beginning of\n\tthe string. The final state will have a special value, as specified in\n\toptions. All other \"in between\" substrings will have a default end state.\n\n\tThis turns the state machine into a Trie-like data structure (rather than a\n\tintelligently-designed DFA).\n\n\tNote that I haven't really tried these with any strings other than\n\tDOMAIN.\n\n\t@param {String} str\n\t@param {CharacterState} start State to jump from the first character\n\t@param {Class} endToken Token class to emit when the given string has been\n\t\tmatched and no more jumps exist.\n\t@param {Class} defaultToken \"Filler token\", or which token type to emit when\n\t\twe don't have a full match\n\t@return {Array} list of newly-created states\n*/\nfunction stateify(str, start, endToken, defaultToken) {\n\tvar i = 0,\n\t    len = str.length,\n\t    state = start,\n\t    newStates = [],\n\t    nextState = void 0;\n\n\t// Find the next state without a jump to the next character\n\twhile (i < len && (nextState = state.next(str[i]))) {\n\t\tstate = nextState;\n\t\ti++;\n\t}\n\n\tif (i >= len) {\n\t\treturn [];\n\t} // no new tokens were added\n\n\twhile (i < len - 1) {\n\t\tnextState = new CharacterState(defaultToken);\n\t\tnewStates.push(nextState);\n\t\tstate.on(str[i], nextState);\n\t\tstate = nextState;\n\t\ti++;\n\t}\n\n\tnextState = new CharacterState(endToken);\n\tnewStates.push(nextState);\n\tstate.on(str[len - 1], nextState);\n\n\treturn newStates;\n}\n\nexports.CharacterState = CharacterState;\nexports.TokenState = TokenState;\nexports.stateify = stateify;"]},"metadata":{},"sourceType":"script"}