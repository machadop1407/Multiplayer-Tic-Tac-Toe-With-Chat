{"ast":null,"code":"'use strict';\n/**\nBase interface for a node in an XML document.\n\n@public\n*/\n\nclass XmlNode {\n  constructor() {\n    /**\n    Parent node of this node, or `null` if this node has no parent.\n     @type {XmlDocument|XmlElement|null}\n    @public\n    */\n    this.parent = null;\n  }\n  /**\n  Document that contains this node, or `null` if this node is not associated\n  with a document.\n   @type {XmlDocument?}\n  @public\n  */\n\n\n  get document() {\n    return this.parent ? this.parent.document : null;\n  }\n  /**\n  Whether this node is the root node of the document.\n   @returns {boolean}\n  @public\n  */\n\n\n  get isRootNode() {\n    return this.parent ? this.parent === this.document : false;\n  }\n  /**\n  Whether whitespace should be preserved in the content of this element and\n  its children.\n   This is influenced by the value of the special `xml:space` attribute, and\n  will be `true` for any node whose `xml:space` attribute is set to\n  \"preserve\". If a node has no such attribute, it will inherit the value of\n  the nearest ancestor that does (if any).\n   @type {boolean}\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n  @public\n  */\n\n\n  get preserveWhitespace() {\n    return Boolean(this.parent && this.parent.preserveWhitespace);\n  }\n  /**\n  Type of this node.\n   The value of this property is a string that matches one of the static `TYPE_*`\n  properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`, `TYPE_TEXT`, etc.).\n   The `XmlNode` class itself is a base class and doesn't have its own type name.\n   @type {string}\n  @public\n  */\n\n\n  get type() {\n    return '';\n  }\n  /**\n  Returns a JSON-serializable object representing this node, minus properties\n  that could result in circular references.\n   @returns {{[key: string]: any}}\n  @public\n  */\n\n\n  toJSON() {\n    /** @type {{[key: string]: any}} */\n    let json = {\n      type: this.type\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    return json;\n  }\n\n}\n/**\nType value for an `XmlCdata` node.\n\n@type {string}\n@public\n*/\n\n\nXmlNode.TYPE_CDATA = 'cdata';\n/**\nType value for an `XmlComment` node.\n\n@type {string}\n@public\n*/\n\nXmlNode.TYPE_COMMENT = 'comment';\n/**\nType value for an `XmlDocument` node.\n\n@type {string}\n@public\n*/\n\nXmlNode.TYPE_DOCUMENT = 'document';\n/**\nType value for an `XmlElement` node.\n\n@type {string}\n@public\n*/\n\nXmlNode.TYPE_ELEMENT = 'element';\n/**\nType value for an `XmlProcessingInstruction` node.\n\n@type {string}\n@public\n*/\n\nXmlNode.TYPE_PROCESSING_INSTRUCTION = 'pi';\n/**\nType value for an `XmlText` node.\n\n@type {string}\n@public\n*/\n\nXmlNode.TYPE_TEXT = 'text';\nmodule.exports = XmlNode;\n/** @typedef {import('./XmlDocument')} XmlDocument */\n\n/** @typedef {import('./XmlElement')} XmlElement */","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/@rgrove/parse-xml/src/lib/XmlNode.js"],"names":["XmlNode","constructor","parent","document","isRootNode","preserveWhitespace","Boolean","type","toJSON","json","TYPE_CDATA","TYPE_COMMENT","TYPE_DOCUMENT","TYPE_ELEMENT","TYPE_PROCESSING_INSTRUCTION","TYPE_TEXT","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMA,OAAN,CAAc;AACZC,EAAAA,WAAW,GAAG;AACZ;AACJ;AACA;AACA;AACA;AAEI,SAAKC,MAAL,GAAc,IAAd;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEc,MAARC,QAAQ,GAAG;AACb,WAAO,KAAKD,MAAL,GACH,KAAKA,MAAL,CAAYC,QADT,GAEH,IAFJ;AAGD;AAED;AACF;AACA;AACA;AACA;;;AAEgB,MAAVC,UAAU,GAAG;AACf,WAAO,KAAKF,MAAL,GACH,KAAKA,MAAL,KAAgB,KAAKC,QADlB,GAEH,KAFJ;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGwB,MAAlBE,kBAAkB,GAAG;AACvB,WAAOC,OAAO,CAAC,KAAKJ,MAAL,IAAe,KAAKA,MAAL,CAAYG,kBAA5B,CAAd;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIU,MAAJE,IAAI,GAAG;AACT,WAAO,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEEC,EAAAA,MAAM,GAAG;AACP;AACA,QAAIC,IAAI,GAAG;AACTF,MAAAA,IAAI,EAAE,KAAKA;AADF,KAAX;;AAIA,QAAI,KAAKH,UAAT,EAAqB;AACnBK,MAAAA,IAAI,CAACL,UAAL,GAAkB,IAAlB;AACD;;AAED,QAAI,KAAKC,kBAAT,EAA6B;AAC3BI,MAAAA,IAAI,CAACJ,kBAAL,GAA0B,IAA1B;AACD;;AAED,WAAOI,IAAP;AACD;;AA1FW;AA6Fd;AACA;AACA;AACA;AACA;AACA;;;AACAT,OAAO,CAACU,UAAR,GAAqB,OAArB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAV,OAAO,CAACW,YAAR,GAAuB,SAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAX,OAAO,CAACY,aAAR,GAAwB,UAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAZ,OAAO,CAACa,YAAR,GAAuB,SAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAb,OAAO,CAACc,2BAAR,GAAsC,IAAtC;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAd,OAAO,CAACe,SAAR,GAAoB,MAApB;AAEAC,MAAM,CAACC,OAAP,GAAiBjB,OAAjB;AAEA;;AACA","sourcesContent":["'use strict';\n\n/**\nBase interface for a node in an XML document.\n\n@public\n*/\nclass XmlNode {\n  constructor() {\n    /**\n    Parent node of this node, or `null` if this node has no parent.\n\n    @type {XmlDocument|XmlElement|null}\n    @public\n    */\n    this.parent = null;\n  }\n\n  /**\n  Document that contains this node, or `null` if this node is not associated\n  with a document.\n\n  @type {XmlDocument?}\n  @public\n  */\n  get document() {\n    return this.parent\n      ? this.parent.document\n      : null;\n  }\n\n  /**\n  Whether this node is the root node of the document.\n\n  @returns {boolean}\n  @public\n  */\n  get isRootNode() {\n    return this.parent\n      ? this.parent === this.document\n      : false;\n  }\n\n  /**\n  Whether whitespace should be preserved in the content of this element and\n  its children.\n\n  This is influenced by the value of the special `xml:space` attribute, and\n  will be `true` for any node whose `xml:space` attribute is set to\n  \"preserve\". If a node has no such attribute, it will inherit the value of\n  the nearest ancestor that does (if any).\n\n  @type {boolean}\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n  @public\n  */\n  get preserveWhitespace() {\n    return Boolean(this.parent && this.parent.preserveWhitespace);\n  }\n\n  /**\n  Type of this node.\n\n  The value of this property is a string that matches one of the static `TYPE_*`\n  properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`, `TYPE_TEXT`, etc.).\n\n  The `XmlNode` class itself is a base class and doesn't have its own type name.\n\n  @type {string}\n  @public\n  */\n  get type() {\n    return '';\n  }\n\n  /**\n  Returns a JSON-serializable object representing this node, minus properties\n  that could result in circular references.\n\n  @returns {{[key: string]: any}}\n  @public\n  */\n  toJSON() {\n    /** @type {{[key: string]: any}} */\n    let json = {\n      type: this.type\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    return json;\n  }\n}\n\n/**\nType value for an `XmlCdata` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_CDATA = 'cdata';\n\n/**\nType value for an `XmlComment` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_COMMENT = 'comment';\n\n/**\nType value for an `XmlDocument` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_DOCUMENT = 'document';\n\n/**\nType value for an `XmlElement` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_ELEMENT = 'element';\n\n/**\nType value for an `XmlProcessingInstruction` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n/**\nType value for an `XmlText` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_TEXT = 'text';\n\nmodule.exports = XmlNode;\n\n/** @typedef {import('./XmlDocument')} XmlDocument */\n/** @typedef {import('./XmlElement')} XmlElement */\n"]},"metadata":{},"sourceType":"script"}