{"ast":null,"code":"'use strict';\n\nconst Parser = require('./lib/Parser');\n\nconst XmlCdata = require('./lib/XmlCdata');\n\nconst XmlComment = require('./lib/XmlComment');\n\nconst XmlDocument = require('./lib/XmlDocument');\n\nconst XmlElement = require('./lib/XmlElement');\n\nconst XmlNode = require('./lib/XmlNode');\n\nconst XmlProcessingInstruction = require('./lib/XmlProcessingInstruction');\n\nconst XmlText = require('./lib/XmlText');\n/**\nParses the given XML string and returns an `XmlDocument` instance representing\nthe document tree.\n\n@example\n\n  const parseXml = require('@rgrove/parse-xml');\n  let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n\n@param {string} xml\n  XML string to parse.\n\n@param {object} [options]\n  Parsing options.\n\n  @param {boolean} [options.ignoreUndefinedEntities=false]\n    When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n    output as is instead of causing a parse error.\n\n  @param {boolean} [options.preserveCdata=false]\n    When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n    nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n    which keeps the node tree simpler and easier to work with.\n\n  @param {boolean} [options.preserveComments=false]\n    When `true`, comments will be preserved in the document as `XmlComment`\n    nodes. Otherwise comments will not be included in the node tree.\n\n  @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    When an undefined named entity is encountered, this function will be called\n    with the entity as its only argument. It should return a string value with\n    which to replace the entity, or `null` or `undefined` to treat the entity as\n    undefined (which may result in a parse error depending on the value of\n    `ignoreUndefinedEntities`).\n\n  @param {boolean} [options.sortAttributes=false]\n    When `true`, attributes in an element's `attributes` object will be sorted\n    in alphanumeric order by name. Otherwise they'll retain their original order\n    as found in the XML.\n\n@returns {XmlDocument}\n@public\n*/\n\n\nfunction parseXml(xml, options) {\n  return new Parser(xml, options).document;\n}\n\nparseXml.XmlCdata = XmlCdata;\nparseXml.XmlComment = XmlComment;\nparseXml.XmlDocument = XmlDocument;\nparseXml.XmlElement = XmlElement;\nparseXml.XmlNode = XmlNode;\nparseXml.XmlProcessingInstruction = XmlProcessingInstruction;\nparseXml.XmlText = XmlText;\nmodule.exports = parseXml;","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/@rgrove/parse-xml/src/index.js"],"names":["Parser","require","XmlCdata","XmlComment","XmlDocument","XmlElement","XmlNode","XmlProcessingInstruction","XmlText","parseXml","xml","options","document","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,eAAD,CAAvB;;AACA,MAAMM,wBAAwB,GAAGN,OAAO,CAAC,gCAAD,CAAxC;;AACA,MAAMO,OAAO,GAAGP,OAAO,CAAC,eAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,QAAT,CAAkBC,GAAlB,EAAuBC,OAAvB,EAAgC;AAC9B,SAAQ,IAAIX,MAAJ,CAAWU,GAAX,EAAgBC,OAAhB,CAAD,CAA2BC,QAAlC;AACD;;AAEDH,QAAQ,CAACP,QAAT,GAAoBA,QAApB;AACAO,QAAQ,CAACN,UAAT,GAAsBA,UAAtB;AACAM,QAAQ,CAACL,WAAT,GAAuBA,WAAvB;AACAK,QAAQ,CAACJ,UAAT,GAAsBA,UAAtB;AACAI,QAAQ,CAACH,OAAT,GAAmBA,OAAnB;AACAG,QAAQ,CAACF,wBAAT,GAAoCA,wBAApC;AACAE,QAAQ,CAACD,OAAT,GAAmBA,OAAnB;AAEAK,MAAM,CAACC,OAAP,GAAiBL,QAAjB","sourcesContent":["'use strict';\n\nconst Parser = require('./lib/Parser');\nconst XmlCdata = require('./lib/XmlCdata');\nconst XmlComment = require('./lib/XmlComment');\nconst XmlDocument = require('./lib/XmlDocument');\nconst XmlElement = require('./lib/XmlElement');\nconst XmlNode = require('./lib/XmlNode');\nconst XmlProcessingInstruction = require('./lib/XmlProcessingInstruction');\nconst XmlText = require('./lib/XmlText');\n\n/**\nParses the given XML string and returns an `XmlDocument` instance representing\nthe document tree.\n\n@example\n\n  const parseXml = require('@rgrove/parse-xml');\n  let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n\n@param {string} xml\n  XML string to parse.\n\n@param {object} [options]\n  Parsing options.\n\n  @param {boolean} [options.ignoreUndefinedEntities=false]\n    When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n    output as is instead of causing a parse error.\n\n  @param {boolean} [options.preserveCdata=false]\n    When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n    nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n    which keeps the node tree simpler and easier to work with.\n\n  @param {boolean} [options.preserveComments=false]\n    When `true`, comments will be preserved in the document as `XmlComment`\n    nodes. Otherwise comments will not be included in the node tree.\n\n  @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    When an undefined named entity is encountered, this function will be called\n    with the entity as its only argument. It should return a string value with\n    which to replace the entity, or `null` or `undefined` to treat the entity as\n    undefined (which may result in a parse error depending on the value of\n    `ignoreUndefinedEntities`).\n\n  @param {boolean} [options.sortAttributes=false]\n    When `true`, attributes in an element's `attributes` object will be sorted\n    in alphanumeric order by name. Otherwise they'll retain their original order\n    as found in the XML.\n\n@returns {XmlDocument}\n@public\n*/\nfunction parseXml(xml, options) {\n  return (new Parser(xml, options)).document;\n}\n\nparseXml.XmlCdata = XmlCdata;\nparseXml.XmlComment = XmlComment;\nparseXml.XmlDocument = XmlDocument;\nparseXml.XmlElement = XmlElement;\nparseXml.XmlNode = XmlNode;\nparseXml.XmlProcessingInstruction = XmlProcessingInstruction;\nparseXml.XmlText = XmlText;\n\nmodule.exports = parseXml;\n"]},"metadata":{},"sourceType":"script"}