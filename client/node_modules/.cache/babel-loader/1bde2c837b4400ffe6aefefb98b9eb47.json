{"ast":null,"code":"'use strict';\n\nconst ICAL = require('ical.js'); // Copied from https://dxr.mozilla.org/comm-central/source/calendar/timezones/zones.json\n// And compiled using node compile-zones.js\n// See also https://github.com/mozilla-comm/ical.js/issues/195\n\n\nconst timezones = require('./zones-compiled.json');\n\nclass IcalExpander {\n  constructor(opts) {\n    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1000;\n    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;\n    this.jCalData = ICAL.parse(opts.ics);\n    this.component = new ICAL.Component(this.jCalData);\n    this.events = this.component.getAllSubcomponents('vevent').map(vevent => new ICAL.Event(vevent));\n\n    if (this.skipInvalidDates) {\n      this.events = this.events.filter(evt => {\n        try {\n          evt.startDate.toJSDate();\n          evt.endDate.toJSDate();\n          return true;\n        } catch (err) {\n          // skipping events with invalid time\n          return false;\n        }\n      });\n    }\n  }\n\n  between(after, before) {\n    function isEventWithinRange(startTime, endTime) {\n      return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());\n    }\n\n    function getTimes(eventOrOccurrence) {\n      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();\n      let endTime = eventOrOccurrence.endDate.toJSDate().getTime(); // If it is an all day event, the end date is set to 00:00 of the next day\n      // So we need to make it be 23:59:59 to compare correctly with the given range\n\n      if (eventOrOccurrence.endDate.isDate && endTime > startTime) {\n        endTime -= 1;\n      }\n\n      return {\n        startTime,\n        endTime\n      };\n    }\n\n    const exceptions = [];\n    this.events.forEach(event => {\n      if (event.isRecurrenceException()) exceptions.push(event);\n    });\n    const ret = {\n      events: [],\n      occurrences: []\n    };\n    this.events.filter(e => !e.isRecurrenceException()).forEach(event => {\n      const exdates = [];\n      event.component.getAllProperties('exdate').forEach(exdateProp => {\n        const exdate = exdateProp.getFirstValue();\n        exdates.push(exdate.toJSDate().getTime());\n      }); // Recurring event is handled differently\n\n      if (event.isRecurring()) {\n        const iterator = event.iterator();\n        let next;\n        let i = 0;\n\n        do {\n          i += 1;\n          next = iterator.next();\n\n          if (next) {\n            const occurrence = event.getOccurrenceDetails(next);\n            const {\n              startTime,\n              endTime\n            } = getTimes(occurrence);\n            const isOccurrenceExcluded = exdates.indexOf(startTime) !== -1; // TODO check that within same day?\n\n            const exception = exceptions.find(ex => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime()); // We have passed the max date, stop\n\n            if (before && startTime > before.getTime()) break; // Check that we are within our range\n\n            if (isEventWithinRange(startTime, endTime)) {\n              if (exception) {\n                ret.events.push(exception);\n              } else if (!isOccurrenceExcluded) {\n                ret.occurrences.push(occurrence);\n              }\n            }\n          }\n        } while (next && (!this.maxIterations || i < this.maxIterations));\n\n        return;\n      } // Non-recurring event:\n\n\n      const {\n        startTime,\n        endTime\n      } = getTimes(event);\n      if (isEventWithinRange(startTime, endTime)) ret.events.push(event);\n    });\n    return ret;\n  }\n\n  before(before) {\n    return this.between(undefined, before);\n  }\n\n  after(after) {\n    return this.between(after);\n  }\n\n  all() {\n    return this.between();\n  }\n\n}\n\nfunction registerTimezones() {\n  Object.keys(timezones).forEach(key => {\n    const icsData = timezones[key];\n    const icsTimezone = `BEGIN:VTIMEZONE\\r\\nTZID:${key}\\r\\n${icsData}\\r\\nEND:VTIMEZONE`;\n    const parsed = ICAL.parse(`BEGIN:VCALENDAR\\nPRODID:-//tzurl.org//NONSGML Olson 2012h//EN\\nVERSION:2.0\\n${icsTimezone}\\nEND:VCALENDAR`);\n    const comp = new ICAL.Component(parsed);\n    const vtimezone = comp.getFirstSubcomponent('vtimezone');\n    ICAL.TimezoneService.register(key, new ICAL.Timezone(vtimezone));\n  });\n}\n\nregisterTimezones();\nmodule.exports = IcalExpander;","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/ical-expander/index.js"],"names":["ICAL","require","timezones","IcalExpander","constructor","opts","maxIterations","skipInvalidDates","jCalData","parse","ics","component","Component","events","getAllSubcomponents","map","vevent","Event","filter","evt","startDate","toJSDate","endDate","err","between","after","before","isEventWithinRange","startTime","endTime","getTime","getTimes","eventOrOccurrence","isDate","exceptions","forEach","event","isRecurrenceException","push","ret","occurrences","e","exdates","getAllProperties","exdateProp","exdate","getFirstValue","isRecurring","iterator","next","i","occurrence","getOccurrenceDetails","isOccurrenceExcluded","indexOf","exception","find","ex","uid","recurrenceId","undefined","all","registerTimezones","Object","keys","key","icsData","icsTimezone","parsed","comp","vtimezone","getFirstSubcomponent","TimezoneService","register","Timezone","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ICAL = require('ical.js');\n\n// Copied from https://dxr.mozilla.org/comm-central/source/calendar/timezones/zones.json\n// And compiled using node compile-zones.js\n// See also https://github.com/mozilla-comm/ical.js/issues/195\nconst timezones = require('./zones-compiled.json');\n\nclass IcalExpander {\n  constructor(opts) {\n    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1000;\n    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;\n\n    this.jCalData = ICAL.parse(opts.ics);\n    this.component = new ICAL.Component(this.jCalData);\n    this.events = this.component.getAllSubcomponents('vevent').map(vevent => new ICAL.Event(vevent));\n\n    if (this.skipInvalidDates) {\n      this.events = this.events.filter((evt) => {\n        try {\n          evt.startDate.toJSDate();\n          evt.endDate.toJSDate();\n          return true;\n        } catch (err) {\n          // skipping events with invalid time\n          return false;\n        }\n      });\n    }\n  }\n\n  between(after, before) {\n    function isEventWithinRange(startTime, endTime) {\n      return (!after || endTime >= after.getTime()) &&\n      (!before || startTime <= before.getTime());\n    }\n\n    function getTimes(eventOrOccurrence) {\n      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();\n      let endTime = eventOrOccurrence.endDate.toJSDate().getTime();\n\n      // If it is an all day event, the end date is set to 00:00 of the next day\n      // So we need to make it be 23:59:59 to compare correctly with the given range\n      if (eventOrOccurrence.endDate.isDate && (endTime > startTime)) {\n        endTime -= 1;\n      }\n\n      return { startTime, endTime };\n    }\n\n    const exceptions = [];\n\n    this.events.forEach((event) => {\n      if (event.isRecurrenceException()) exceptions.push(event);\n    });\n\n    const ret = {\n      events: [],\n      occurrences: [],\n    };\n\n    this.events.filter(e => !e.isRecurrenceException()).forEach((event) => {\n      const exdates = [];\n\n      event.component.getAllProperties('exdate').forEach((exdateProp) => {\n        const exdate = exdateProp.getFirstValue();\n        exdates.push(exdate.toJSDate().getTime());\n      });\n\n      // Recurring event is handled differently\n      if (event.isRecurring()) {\n        const iterator = event.iterator();\n\n        let next;\n        let i = 0;\n\n        do {\n          i += 1;\n          next = iterator.next();\n          if (next) {\n            const occurrence = event.getOccurrenceDetails(next);\n\n            const { startTime, endTime } = getTimes(occurrence);\n\n            const isOccurrenceExcluded = exdates.indexOf(startTime) !== -1;\n\n            // TODO check that within same day?\n            const exception = exceptions.find(ex => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());\n\n            // We have passed the max date, stop\n            if (before && startTime > before.getTime()) break;\n\n            // Check that we are within our range\n            if (isEventWithinRange(startTime, endTime)) {\n              if (exception) {\n                ret.events.push(exception);\n              } else if (!isOccurrenceExcluded) {\n                ret.occurrences.push(occurrence);\n              }\n            }\n          }\n        }\n        while (next && (!this.maxIterations || i < this.maxIterations));\n\n        return;\n      }\n\n      // Non-recurring event:\n      const { startTime, endTime } = getTimes(event);\n\n      if (isEventWithinRange(startTime, endTime)) ret.events.push(event);\n    });\n\n    return ret;\n  }\n\n  before(before) {\n    return this.between(undefined, before);\n  }\n\n  after(after) {\n    return this.between(after);\n  }\n\n  all() {\n    return this.between();\n  }\n}\n\nfunction registerTimezones() {\n  Object.keys(timezones).forEach((key) => {\n    const icsData = timezones[key];\n    const icsTimezone = `BEGIN:VTIMEZONE\\r\\nTZID:${key}\\r\\n${icsData}\\r\\nEND:VTIMEZONE`;\n    const parsed = ICAL.parse(`BEGIN:VCALENDAR\\nPRODID:-//tzurl.org//NONSGML Olson 2012h//EN\\nVERSION:2.0\\n${icsTimezone}\\nEND:VCALENDAR`);\n    const comp = new ICAL.Component(parsed);\n    const vtimezone = comp.getFirstSubcomponent('vtimezone');\n\n    ICAL.TimezoneService.register(key, new ICAL.Timezone(vtimezone));\n  });\n}\n\nregisterTimezones();\n\nmodule.exports = IcalExpander;\n"]},"metadata":{},"sourceType":"script"}