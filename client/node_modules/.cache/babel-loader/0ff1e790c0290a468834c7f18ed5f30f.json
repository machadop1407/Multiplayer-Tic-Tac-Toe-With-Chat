{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n\n(function () {\n  /* istanbul ignore next */\n  if (typeof module === 'object') {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else if (typeof HTMLScriptElement !== 'undefined' && 'noModule' in HTMLScriptElement.prototype) {\n    // Until we use ES6 exports, using <script type=\"module\"> we define ICAL on the window global.\n    window.ICAL = ICAL = {};\n  } else if (typeof ICAL !== 'object') {\n    ICAL = {};\n  }\n})();\n/* jshint ignore:end */\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\n\n\nICAL.foldLength = 75;\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\n\nICAL.newLineChar = '\\r\\n';\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\n\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function (vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    } //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n\n\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    } //create an object with one entry for each required tz\n\n\n    reqTzid = {};\n\n    for (i = 0; i < properties.length; i++) {\n      if (tzid = properties[i].getParameter(\"tzid\")) {\n        reqTzid[tzid] = true;\n      }\n    } //delete any vtimezones that are not on the reqTzid list.\n\n\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    } //create any missing, but registered timezones\n\n\n    for (i in reqTzid) {\n      if (reqTzid.hasOwnProperty(i) && !vtimezones[i] && ICAL.TimezoneService.has(i)) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function (number) {\n    return typeof number === 'number' && isNaN(number);\n  },\n\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function (string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error('Could not extract integer from \"' + string + '\"');\n    }\n\n    return result;\n  },\n\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n\n    return new type(data);\n  },\n\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function (buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function (list, seekVal, cmpfunc) {\n    if (!list.length) return 0;\n    var low = 0,\n        high = list.length - 1,\n        mid,\n        cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n      if (cmpval < 0) high = mid - 1;else if (cmpval > 0) low = mid + 1;else break;\n    }\n\n    if (cmpval < 0) return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0) return mid + 1;else return mid;\n  },\n\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn:\n  /* istanbul ignore next */\n  function () {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof console !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function (aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n\n      return arr;\n    } else {\n      var obj = {};\n\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n\n      return obj;\n    }\n  },\n\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\",\n        pos = 0,\n        line_length = 0; //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;else if (cp < 2048) line_length += 2; //needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;else line_length += 4; //cp is less than 1114112\n\n      if (line_length < ICAL.foldLength + 1) pos += cp > 65535 ? 2 : 1;else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof data !== 'string') {\n      // handle fractions.\n      if (typeof data === 'number') {\n        data = parseInt(data);\n      }\n\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n\n      case 1:\n        return '0' + data;\n\n      default:\n        return data;\n    }\n  },\n\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n  },\n\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function (base, child, extra) {\n    function F() {}\n\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function (source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\nICAL.design = function () {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n      fromICAL: function (aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n      toICAL: function (aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape) regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function (str) {\n          switch (str) {\n            case \"\\\\\":\n              return \"\\\\\\\\\";\n\n            case \";\":\n              return \"\\\\;\";\n\n            case \",\":\n              return \"\\\\,\";\n\n            case \"\\n\":\n              return \"\\\\n\";\n\n            /* istanbul ignore next */\n\n            default:\n              return str;\n          }\n        });\n      }\n    };\n    return result;\n  } // default types used multiple times\n\n\n  var DEFAULT_TYPE_TEXT = {\n    defaultType: \"text\"\n  };\n  var DEFAULT_TYPE_TEXT_MULTI = {\n    defaultType: \"text\",\n    multiValue: \",\"\n  };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = {\n    defaultType: \"text\",\n    structuredValue: \";\"\n  };\n  var DEFAULT_TYPE_INTEGER = {\n    defaultType: \"integer\"\n  };\n  var DEFAULT_TYPE_DATETIME_DATE = {\n    defaultType: \"date-time\",\n    allowedTypes: [\"date-time\", \"date\"]\n  };\n  var DEFAULT_TYPE_DATETIME = {\n    defaultType: \"date-time\"\n  };\n  var DEFAULT_TYPE_URI = {\n    defaultType: \"uri\"\n  };\n  var DEFAULT_TYPE_UTCOFFSET = {\n    defaultType: \"utc-offset\"\n  };\n  var DEFAULT_TYPE_RECUR = {\n    defaultType: \"recur\"\n  };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = {\n    defaultType: \"date-and-or-time\",\n    allowedTypes: [\"date-time\", \"date\", \"text\"]\n  };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n\n      case \"\\\\;\":\n        return \";\";\n\n      case \"\\\\,\":\n        return \",\";\n\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n\n      /* istanbul ignore next */\n\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n\n    if (structuredEscape) newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n      fromICAL: function (aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n\n          case 'FALSE':\n            return false;\n\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n      toICAL: function (aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n\n        return 'FALSE';\n      }\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n      fromICAL: function (aValue) {\n        var parsed = parseFloat(aValue);\n\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n\n        return parsed;\n      },\n      toICAL: function (aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function (aValue) {\n        var parsed = parseInt(aValue);\n\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n\n        return parsed;\n      },\n      toICAL: function (aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function (aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) + aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);\n        }\n      },\n      fromICAL: function (aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2) + ':' + aValue.substr(5, 2);\n        }\n      },\n      decorate: function (aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n    // CN just wants a param-value\n    // \"CN\": { ... }\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\", \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\", \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\", \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\", \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  }; // When adding a value here, be sure to add it to the parameter types!\n\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n    uri: {// TODO\n\n      /* ... */\n    },\n    \"binary\": {\n      decorate: function (aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n      undecorate: function (aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {// needs to be an uri\n    },\n    \"date\": {\n      decorate: function (aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2);\n        }\n      },\n      toICAL: function (aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n      }\n    },\n    \"date-time\": {\n      fromICAL: function (aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2) + 'T' + aValue.substr(9, 2) + ':' + aValue.substr(11, 2) + ':' + aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n      toICAL: function (aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment\n          aValue.substr(8, 5) + // MM\n          aValue.substr(14, 2) + // SS\n          aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n      decorate: function (aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function (aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n      fromICAL: function (string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n      toICAL: function (parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n      decorate: function (aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n      undecorate: function (aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function (string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n      toICAL: function (data) {\n        var str = \"\";\n\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n\n          var val = data[k];\n\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n\n        return str.substr(0, str.length - 1);\n      },\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n      undecorate: function (aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n    time: {\n      fromICAL: function (aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        } // HH::MM::SSZ?\n\n\n        var result = aValue.substr(0, 2) + ':' + aValue.substr(2, 2) + ':' + aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n      toICAL: function (aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": {\n      defaultType: \"uri\"\n    },\n    \"attendee\": {\n      defaultType: \"cal-address\"\n    },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": {\n      defaultType: \"duration\"\n    },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": {\n      defaultType: \"period\",\n      multiValue: \",\"\n    },\n    \"geo\": {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": {\n      defaultType: \"cal-address\"\n    },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function (string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": {\n      defaultType: \"duration\",\n      allowedTypes: [\"duration\", \"date-time\"]\n    },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  }); // When adding a value here, be sure to add it to the parameter types!\n\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    date: {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function (aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n    time: {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n\n        var zone = splitzone[0],\n            value = splitzone[1]; //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2) + ':' + value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n      toICAL: function (aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n\n        var zone = splitzone[0],\n            value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n      _splitZone: function (aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n    \"date-time\": {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n      toICAL: function (aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n    \"date-and-or-time\": {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') + (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n      toICAL: function (aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) + (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n\n    }\n  });\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\", \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": {\n      defaultType: \"language-tag\"\n    },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": {\n      defaultType: \"text\",\n      structuredValue: \";\"\n    },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": {\n      defaultType: \"timestamp\"\n    },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": {\n      defaultType: \"uri\",\n      allowedTypes: [\"uri\", \"text\"]\n    },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": {\n      defaultType: \"text\",\n      allowedTypes: [\"text\", \"utc-offset\", \"uri\"]\n    },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {// TODO\n\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function (aValue) {\n        return aValue.substr(0, 7);\n      },\n      fromICAL: function (aValue) {\n        return aValue.substr(0, 7);\n      },\n      decorate: function (aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function (string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    adr: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    label: DEFAULT_TYPE_TEXT,\n    tel: {\n      defaultType: \"phone-number\"\n    },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n    tz: {\n      defaultType: \"utc-offset\",\n      allowedTypes: [\"utc-offset\", \"text\"]\n    },\n    geo: {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    agent: {\n      defaultType: \"vcard\",\n      allowedTypes: [\"vcard\", \"text\", \"uri\"]\n    },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function (string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    class: DEFAULT_TYPE_TEXT,\n    key: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"text\"]\n    }\n  });\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function (componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n  return design;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\n\n\nICAL.stringify = function () {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n\n\n  stringify.component = function (component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n    var designSetName = component[0]; // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n\n    if (designSetName === 'vcard' && component[1].length > 0 && !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    } // Ignore subcomponents if none exist, e.g. in vCard.\n\n\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n\n\n  stringify.property = function (property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n    var line = name;\n    var paramName;\n\n    for (paramName in params) {\n      var value = params[paramName];\n      /* istanbul ignore else */\n\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;\n\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if ('structuredValue' in propDetails && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    } // push the VALUE property if type is not the default\n    // for the current property.\n\n\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);\n    } else if (multiValue) {\n      line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);\n    } else if (structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n\n\n  stringify.propertyValue = function (value) {\n    if (helpers.unescapedIndexOf(value, ',') === -1 && helpers.unescapedIndexOf(value, ':') === -1 && helpers.unescapedIndexOf(value, ';') === -1) {\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n\n\n  stringify.multiValue = function (values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== len - 1) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n\n\n  stringify.value = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n\n    return value;\n  };\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n\n\n  stringify._rfc6868Unescape = function (val) {\n    return val.replace(/[\\n^\"]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n\n  var RFC6868_REPLACE_MAP = {\n    '\"': \"^'\",\n    \"\\n\": \"^n\",\n    \"^\": \"^^\"\n  };\n  return stringify;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\n\n\nICAL.parse = function () {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n    state.stack = [root];\n\n    parser._eachLine(input, function (err, line) {\n      parser._handleContentLine(line, state);\n    }); // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n\n\n    if (state.stack.length > 1) {\n      throw new ParserError('invalid ical body. component began but did not end');\n    }\n\n    state = null;\n    return root.length == 1 ? root[0] : root;\n  }\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n\n\n  parser.property = function (str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n\n    parser._handleContentLine(str, state);\n\n    return state.component[1][0];\n  };\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n\n\n  parser.component = function (str) {\n    return parser(str);\n  }; // classes & constants\n\n\n  parser.ParserError = ParserError;\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n\n  parser._handleContentLine = function (line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n    var lastParamIndex;\n    var lastValuePos; // name of property or begin/end\n\n    var name;\n    var value; // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n\n    var params = {};\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n    // when the parameter delimiter is after the\n    // value delimiter then it is not a parameter.\n\n    if (paramPos !== -1 && valuePos !== -1) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n\n      if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n\n        state.stack.push(state.component);\n        state.component = newComponent;\n\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      } // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError('invalid line (no token \";\" or \":\") \"' + line + '\"');\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    } // attempt to determine value\n\n\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    } // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n\n\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 && !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n\n    state.component[1].push(result);\n  };\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n\n\n  parser._parseValue = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n\n    return value;\n  };\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n\n\n  parser._parseParameters = function (line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value,\n        valuePos = -1;\n    var type, multiValue, mvdelim; // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n\n        if (multiValue && pos != -1) {\n          var extendedValue = true;\n\n          while (extendedValue) {\n            if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n              pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n            } else {\n              extendedValue = false;\n            }\n          }\n        }\n\n        if (pos === -1) {\n          throw new ParserError('invalid line (no matching double quote) \"' + line + '\"');\n        }\n\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1; // move to next \";\"\n\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && lcname in result) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [result[lcname], value];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n\n    return [result, value, valuePos];\n  };\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n\n\n  parser._rfc6868Escape = function (val) {\n    return val.replace(/\\^['n^]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n\n  var RFC6868_REPLACE_MAP = {\n    \"^'\": '\"',\n    \"^n\": \"\\n\",\n    \"^^\": \"^\"\n  };\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n\n  parser._parseMultiValue = function (buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n\n    if (delim.length === 0) {\n      return buffer;\n    } // split each piece\n\n\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n\n      result.push(value);\n      lastPos = pos + delim.length;\n    } // on the last piece take the rest of string\n\n\n    value = buffer.substr(lastPos);\n\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n\n    result.push(value);\n    return result.length == 1 ? result[0] : result;\n  };\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n\n\n  parser._eachLine = function (buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(lastPos + 1, pos - lastPos - (newlineOffset + 1));\n      } else {\n        if (line) callback(null, line); // push line\n\n        line = buffer.substr(lastPos, pos - lastPos - newlineOffset);\n      }\n\n      lastPos = pos;\n    } while (pos !== len); // extra ending line\n\n\n    line = line.trim();\n    if (line.length) callback(null, line);\n  };\n\n  return parser;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Component = function () {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n\n  function Component(jCal, parent) {\n    if (typeof jCal === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    } // mostly for legacy reasons.\n\n\n    this.jCal = jCal;\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function (index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(this.jCal[COMPONENT_INDEX][index], this);\n      this._hydratedComponentCount++;\n      return this._components[index] = comp;\n    },\n    _hydrateProperty: function (index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(this.jCal[PROPERTY_INDEX][index], this);\n      this._hydratedPropertyCount++;\n      return this._properties[index] = prop;\n    },\n\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function (name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      } // ensure we return a value (strict mode)\n\n\n      return null;\n    },\n\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function (name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(this._hydrateComponent(i));\n          }\n        }\n\n        return result;\n      } else {\n        if (!this._components || this._hydratedComponentCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function (name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n      var i = 0;\n\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function (name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function (name) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function (name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(this._hydrateProperty(i));\n          }\n        }\n\n        return result;\n      } else {\n        if (!this._properties || this._hydratedPropertyCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n    _removeObjectByIndex: function (jCalIndex, cache, index) {\n      cache = cache || []; // remove cached version\n\n      if (cache[index]) {\n        var obj = cache[index];\n\n        if (\"parent\" in obj) {\n          obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1); // remove it from the jCal\n\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n    _removeObject: function (jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof nameOrObject === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    _removeAllObjects: function (jCalIndex, cache, name) {\n      var cached = this[cache]; // Unfortunately we have to run through all children to reset their\n      // parent property.\n\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1; // descending search required because splice\n      // is used and will effect the indices.\n\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function (component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function (nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n\n      return removed;\n    },\n\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function (name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function (property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function (name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n      this.addProperty(prop);\n      return prop;\n    },\n\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function (name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function (nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n\n      return removed;\n    },\n\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function (name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function () {\n      return ICAL.stringify.component(this.jCal, this._designSet);\n    }\n  };\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n\n  Component.fromString = function (str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Property = function () {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n  var design = ICAL.design;\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof jCal === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n\n    this._updateType();\n  }\n\n  Property.prototype = {\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function () {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = 'multiValue' in designSet.property[this.name];\n          this.isStructuredValue = 'structuredValue' in designSet.property[this.name];\n        }\n      }\n    },\n\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function (index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      } // for the case where there is no value.\n\n\n      if (this.jCal.length <= VALUE_INDEX + index) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n\n        return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function (value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function (value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function (value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof value === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function (name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function (name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function (name, value) {\n      var lcname = name.toLowerCase();\n\n      if (typeof value === \"string\" && lcname in this._designSet.param && 'multiValue' in this._designSet.param[lcname]) {\n        value = [value];\n      }\n\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function (name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function () {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n\n      return design.defaultType;\n    },\n\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function (type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n\n      this._updateType();\n    },\n\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function () {\n      return this._hydrateValue(0);\n    },\n\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function () {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function () {\n      if (this._values) {\n        this._values.length = 0;\n      }\n\n      this.jCal.length = 3;\n    },\n\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function (values) {\n      if (!this.isMultiValue) {\n        throw new Error(this.name + ': does not not support mulitValue.\\n' + 'override isMultiValue');\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 && typeof values[0] === 'object' && 'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function (value) {\n      this.removeAllValues();\n\n      if (typeof value === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function () {\n      return ICAL.stringify.property(this.jCal, this._designSet, true);\n    }\n  };\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n\n  Property.fromString = function (str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.UtcOffset = function () {\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function () {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function (aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      this._normalize();\n    },\n\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function (aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function () {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n    _normalize: function () {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n\n      while (secs < -43200) {\n        // = UTC-12:00\n        secs += 97200;\n      }\n\n      while (secs > 50400) {\n        // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs); // Avoid changing the factor when on zero seconds\n\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function () {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") + ICAL.helpers.pad2(this.hours) + ':' + ICAL.helpers.pad2(this.minutes);\n    }\n  };\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n\n  UtcOffset.fromString = function (aString) {\n    // -05:00\n    var options = {}; //TODO: support seconds per rfc5545 ?\n\n    options.factor = aString[0] === '+' ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n    return new ICAL.UtcOffset(options);\n  };\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n\n\n  UtcOffset.fromSeconds = function (aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Binary = function () {\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafa Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n          o2,\n          o3,\n          h1,\n          h2,\n          h3,\n          h4,\n          bits,\n          i = 0,\n          ac = 0,\n          enc = \"\",\n          tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do {\n        // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n        bits = o1 << 16 | o2 << 8 | o3;\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f; // use hexets to index into b64, and append result to encoded string\n\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n      var r = data.length % 3;\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n    },\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n          o2,\n          o3,\n          h1,\n          h2,\n          h3,\n          h4,\n          bits,\n          i = 0,\n          ac = 0,\n          dec = \"\",\n          tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do {\n        // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n      return dec;\n    },\n\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function () {\n      return this.value;\n    }\n  };\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n\n  Binary.fromString = function (aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function () {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function () {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function () {\n      return this.start.toICALString() + \"/\" + (this.end || this.duration).toICALString();\n    }\n  };\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error('Invalid string value: \"' + str + '\" must contain a \"/\" char.');\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n\n\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n\n\n  ICAL.Period.fromJSON = function (aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;\n      return this.isNegative ? -seconds : seconds;\n    },\n\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.isNegative = aSeconds < 0;\n      this.days = ICAL.helpers.trunc(secs / 86400); // If we have a flat number of weeks, use them.\n\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"isNegative\"];\n\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n\n        var prop = propsToCopy[key];\n\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n\n        return str;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function () {\n      return this.toString();\n    }\n  };\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return new ICAL.Duration().fromSeconds(aSeconds);\n  };\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n\n\n  function parseDurationChunk(letter, number, object) {\n    var type;\n\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        } // period\n\n\n        break;\n\n      case 'D':\n        type = 'days';\n        break;\n\n      case 'W':\n        type = 'weeks';\n        break;\n\n      case 'H':\n        type = 'hours';\n        break;\n\n      case 'M':\n        type = 'minutes';\n        break;\n\n      case 'S':\n        type = 'seconds';\n        break;\n\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error('invalid duration value: Missing number before \"' + letter + '\"');\n      }\n\n      var num = parseInt(number, 10);\n\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error('invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"');\n      }\n\n      object[type] = num;\n    }\n\n    return 1;\n  }\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n\n\n  ICAL.Duration.isValueString = function (string) {\n    return string[0] === 'P' || string[1] === 'P';\n  };\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n\n\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error('invalid duration value: Not enough duration components in \"' + aStr + '\"');\n    }\n\n    return new ICAL.Duration(dict);\n  };\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n\n\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n(function () {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\", \"latitude\", \"longitude\"];\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        } // Copy remaining passed properties\n\n\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      } // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n\n\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n\n      var change_num_to_use = -1;\n      var step = 1; // TODO: replace with bin search?\n\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      } // TODO return is_daylight?\n\n\n      return zone_change.utcOffset;\n    },\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(this.changes, change, ICAL.Timezone._compare_change_fn);\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n    _ensureCoverage: function (aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n    _expandComponent: function (aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") || !aComponent.hasProperty(\"tzoffsetto\") || !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = aComponent.name == \"daylight\";\n        changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue());\n        changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue());\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n        ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n          var occ;\n\n          while (occ = iterator.next()) {\n            change = init_changes();\n\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n            ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.tznames ? this.tznames : this.tzid;\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;else if (a.year > b.year) return 1;\n    if (a.month < b.month) return -1;else if (a.month > b.month) return 1;\n    if (a.day < b.day) return -1;else if (a.day > b.day) return 1;\n    if (a.hour < b.hour) return -1;else if (a.hour > b.hour) return 1;\n    if (a.minute < b.minute) return -1;else if (a.minute > b.minute) return 1;\n    if (a.second < b.second) return -1;else if (a.second > b.second) return 1;\n    return 0;\n  };\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n\n\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL.Timezone.localTimezone || to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, -utcOffset);\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n    return null;\n  };\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n\n\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n\n\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.TimezoneService = function () {\n  var zones;\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function () {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function (tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function (tzid) {\n      return zones[tzid];\n    },\n\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function (name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function (tzid) {\n      return delete zones[tzid];\n    }\n  }; // initialize defaults\n\n  TimezoneService.reset();\n  return TimezoneService;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n    /* time defaults */\n\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n  ICAL.Time.prototype = {\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function () {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && \"isDate\" in aData) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(aData.timezone);\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      } // Using Zeller's algorithm\n\n\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n      var h = q + Y + ICAL.helpers.trunc((m + 1) * 26 / 10) + ICAL.helpers.trunc(Y / 4);\n      /* istanbul ignore else */\n\n      if (true\n      /* gregorian */\n      ) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      } // Normalize to 1 = wkst\n\n\n      h = (h + 7 - firstDow) % 7 + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = ICAL.Time.isLeapYear(this.year) ? 1 : 0;\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function () {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n      var start = 0;\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1; // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        } // set current start offset to current day.\n\n\n        start = otherDay.day; // find the current day of week\n\n        var startDow = otherDay.dayOfWeek(); // calculate the difference between current\n        // day of the week and desired day of the week\n\n        var offset = aDayOfWeek - startDow; // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n\n        if (offset < 0) // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7; // add offset to start so start is the same\n        // day of the week as the desired day of week.\n\n        start += offset; // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n\n        start -= aDayOfWeek; // set week day\n\n        weekday = aDayOfWeek;\n      } else {\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth; // find the ends weekday\n\n        var endDow = otherDay.dayOfWeek();\n        pos++;\n        weekday = endDow - aDayOfWeek;\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n      return start + weekday;\n    },\n\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function (aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      } // get pos\n\n\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      } // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n\n\n      var week1;\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = dt.subtractDate(week1).toSeconds() / 86400;\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = aDuration.isNegative ? -1 : 1; // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n      return rc;\n    },\n\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = this.zone.tzid == zone.tzid;\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function () {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' + ICAL.helpers.pad2(this.month) + '-' + ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n        result += 'T' + ICAL.helpers.pad2(this.hour) + ':' + ICAL.helpers.pad2(this.minute) + ':' + ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n\n      this.adjust(0, 0, 0, 0);\n      return this;\n    },\n\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {\n      var minutesOverflow,\n          hoursOverflow,\n          daysOverflow = 0,\n          yearsOverflow = 0;\n      var second, minute, hour, day;\n      var daysInMonth;\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      } // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n\n\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow; // Now take care of the days (and adjust month if needed)\n\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n\n      var offset = this.utcOffset(); // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n\n      var ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset); // seconds\n\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function () {\n      var copy = ['year', 'month', 'day', 'hour', 'minute', 'second', 'isDate'];\n      var result = Object.create(null);\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n          return val;\n        }\n      });\n    }\n    /* istanbul ignore else */\n\n\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n\n\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n    if (month < 1 || month > 12) return days;\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n\n\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return year % 4 == 0;\n    } else {\n      return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n    }\n  };\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n\n\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n\n    if (doy < 1) {\n      year--;\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n\n\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n\n\n  ICAL.Time.fromDateString = function (aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n\n\n  ICAL.Time.fromDateTimeString = function (aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error('invalid date-time value: \"' + aValue + '\"');\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    } // 2012-10-10T10:10:10(Z)?\n\n\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n    return time;\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n\n\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n\n\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n\n\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is floating - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n\n\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n\n\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n    return t;\n  };\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n\n\n  ICAL.Time.getDominicalLetter = function (yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n\n\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n\n\n  ICAL.Time.daysInYearPassedMonth = [[0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]];\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n(function () {\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function (data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n    this.icaltype = icaltype || \"date-and-or-time\";\n    this.fromData(data, zone);\n  };\n\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime,\n  /** @lends ICAL.VCardTime */\n  {\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function () {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n    _normalize: function () {\n      return this;\n    },\n\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function () {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function () {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year,\n          m = this.month,\n          d = this.day;\n      var h = this.hour,\n          mm = this.minute,\n          s = this.second;\n      var hasYear = y !== null,\n          hasMonth = m !== null,\n          hasDay = d !== null;\n      var hasHour = h !== null,\n          hasMinute = mm !== null,\n          hasSecond = s !== null;\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : hasMonth || hasDay ? '--' : '') + (hasMonth ? p2(m) : '') + (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') + (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') + (hasMinute && hasSecond ? ':' : '') + (hasSecond ? p2(s) : '');\n      var zone;\n\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n\n        case \"date\":\n          return datepart;\n      }\n\n      return null;\n    }\n  });\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n\n  ICAL.VCardTime.fromDateAndOrTimeString = function (aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n\n    var parts = aValue.split('T');\n    var dt = parts[0],\n        tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0],\n        tm = splitzone[1];\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n  var REVERSE_DOW_MAP = {};\n\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\", \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\", \"BYMONTH\", \"BYSETPOS\"];\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof data === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function (aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return ucname in this.parts ? this.parts[ucname].slice() : [];\n    },\n\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function (data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function () {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n\n        var kparts = this.parts[k];\n\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n\n      return res;\n    },\n\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be > ' + min);\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be < ' + min);\n    }\n\n    return result;\n  }\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n\n\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return (DOW_MAP[string] - firstDow + 7) % 7 + 1;\n  };\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n\n\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = num + firstDow - ICAL.Time.SUNDAY;\n\n    if (dow > 7) {\n      dow -= 7;\n    }\n\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n  var optionDesign = {\n    FREQ: function (value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error('invalid frequency \"' + value + '\" expected: \"' + ALLOWED_FREQ.join(', ') + '\"');\n      }\n    },\n    COUNT: function (value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n    INTERVAL: function (value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n    UNTIL: function (value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n    WKST: function (value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function (value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n\n  ICAL.Recur.fromString = function (string) {\n    var data = ICAL.Recur._stringToData(string, false);\n\n    return new ICAL.Recur(data);\n  };\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n\n\n  ICAL.Recur.fromData = function (aData) {\n    return new ICAL.Recur(aData);\n  };\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n\n\n  ICAL.Recur._stringToData = function (string, fmtIcal) {\n    var dict = Object.create(null); // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = fmtIcal ? lcname : ucname;\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n\n        dict[name] = partArr.length == 1 ? partArr[0] : partArr;\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.RecurIterator = function () {\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function (options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number) this.occurrence_number = options.occurrence_number;\n      this.days = options.days || [];\n\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      } // If the BYYEARDAY appares, no other date rule part may appear\n\n\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts || \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      } // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n\n\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      } // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n\n\n      if (this.rule.freq == \"MONTHLY\" && (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      } // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n\n\n      if (this.rule.freq == \"WEEKLY\" && (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      } // BYYEARDAY may only appear in YEARLY rules\n\n\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n\n          if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n\n          if (this.days.length > 0) {\n            break;\n          }\n\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year); // Check every weekday in BYDAY with relative dow and pos.\n\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos); // If |pos| >= 6, the byday is invalid for a monthly rule.\n\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          } // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n\n\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n\n        this.last = tempLast.clone(); //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = this.last ? this.last.clone() : null;\n\n      if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n      var valid;\n\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n          case \"SECONDLY\":\n            this.next_second();\n            break;\n\n          case \"MINUTELY\":\n            this.next_minute();\n            break;\n\n          case \"HOURLY\":\n            this.next_hour();\n            break;\n\n          case \"DAILY\":\n            this.next_day();\n            break;\n\n          case \"WEEKLY\":\n            this.next_week();\n            break;\n\n          case \"MONTHLY\":\n            valid = this.next_month();\n            break;\n\n          case \"YEARLY\":\n            this.next_year();\n            break;\n\n          default:\n            return null;\n        }\n      } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid); // TODO is this valid?\n\n\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" + \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\", \"minute\", \"hour\", \"next_second\");\n    },\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\", \"monthday\", \"next_minute\");\n    },\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = this.rule.freq == \"DAILY\";\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        } // HACK should be first month of the year\n\n\n        this.last.month = 1;\n        this.last.day = 1;\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function (year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year); // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n\n      var newRules = [];\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx]; // if this rule falls outside of given\n        // month discard it.\n\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        } // negative case\n\n\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        } // only add unique items...\n\n\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n      } // unique and sort\n\n\n      return newRules.sort(function (a, b) {\n        return a - b;\n      });\n    },\n\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function (isInit) {\n      var byMonthDay; // setup in initMonth\n\n      var byDay = this.by_data.BYDAY;\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n\n      var dayLen = byDay.length; // we are not valid by default\n\n      var dataIsValid = 0;\n      var daysInMonth;\n      var self = this; // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(self.last.month, self.last.year);\n        byMonthDay = self.normalizeByMonthDayRules(self.last.year, self.last.month, self.by_data.BYMONTHDAY);\n        dateLen = byMonthDay.length; // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n\n        while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth(); // should come after initMonth\n\n      if (isInit) {\n        lastDay -= 1;\n      } // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n\n\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--; // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        } // find next date\n\n\n        var next = byMonthDay[dateIdx++]; // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        } // Now we can loop through the day rules to see\n        // if one matches the current month date.\n\n\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n          this.last.day = lastDay;\n\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        } // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n\n\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n      return dataIsValid;\n    },\n    next_month: function next_month() {\n      var this_freq = this.rule.freq == \"MONTHLY\";\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow, this.last.year);\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n        return end_of_data;\n      }\n    },\n    next_year: function next_year() {\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n    _nextByYearDay: function _nextByYearDay() {\n      var doy = this.days[this.days_index];\n      var year = this.last.year;\n\n      if (doy < 1) {\n        // Time.fromDayOfYear(doy, year) indexes relative to the\n        // start of the given year. That is different from the\n        // semantics of BYYEARDAY where negative indexes are an\n        // offset from the end of the given year.\n        doy += 1;\n        year += 1;\n      }\n\n      var next = ICAL.Time.fromDayOfYear(doy, year);\n      this.last.day = next.day;\n      this.last.month = next.month;\n    },\n\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = this.rule.freq == aInterval;\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n    increment_month: function increment_month() {\n      this.last.day = 1;\n\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n    increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n    has_by_data: function has_by_data(aRuleType) {\n      return aRuleType in this.rule.parts;\n    },\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = []; // We need our own copy with a few keys set\n\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {// TODO unimplemented in libical\n      } else if (partCount == 2 && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {// TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n              var first_matching_day = (dow + 7 - first_dow) % 7 + 1;\n              var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        } // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n\n\n        this.days.sort(function (a, b) {\n          return a - b;\n        }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {// TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n\n      return 0;\n    },\n    expand_by_day: function expand_by_day(aYear) {\n      var days_list = [];\n      var tmp = this.last.clone();\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n      var start_dow = tmp.dayOfWeek();\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n        } else if (pos > 0) {\n          var first;\n\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n\n      return days_list;\n    },\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos); // negative numbers are not false-y\n\n        return idx !== -1;\n      }\n\n      return false;\n    },\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n\n      return pass;\n    },\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n      return this.check_contract_restriction(\"BYSECOND\", this.last.second) && this.check_contract_restriction(\"BYMINUTE\", this.last.minute) && this.check_contract_restriction(\"BYHOUR\", this.last.hour) && this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction(\"BYWEEKNO\", weekNo) && this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) && this.check_contract_restriction(\"BYMONTH\", this.last.month) && this.check_contract_restriction(\"BYYEARDAY\", doy);\n    },\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n\n      return deftime;\n    },\n\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function () {\n      var result = Object.create(null);\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n      return result;\n    }\n  };\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n  return icalrecur_iterator;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.RecurExpansion = function () {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') || comp.hasProperty('rrule') || comp.hasProperty('recurrence-id');\n  }\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n\n\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function (options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function (item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof options.complete !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function () {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error('max tries have occured, rule may be impossible to forfill.');\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last); // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        } // no next rule day or recurrence rule is first.\n\n\n        if (!next || iter && next.compare(iter.last) > 0) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone(); // move to next so we can continue\n\n          iter.next();\n        } // if the ruleDate is still next increment it.\n\n\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next; // check the negative rules\n\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          } // if the current rule is excluded skip it.\n\n\n          if (compare === 0) {\n            this._nextExDay();\n\n            continue;\n          }\n        } //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n\n\n        return this.last;\n      }\n    },\n\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function () {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n      return result;\n    },\n\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function (component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(result, prop, compareTime); // ordered insert\n\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function (component) {\n      this.ruleIterators = [];\n      this.last = this.dtstart.clone(); // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate'); // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n\n        if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(this.ruleDates, this.last, compareTime);\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter); // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate'); // if we have a .last day we increment the index to beyond it.\n\n        this.exDateInc = ICAL.helpers.binsearchInsert(this.exDates, this.last, compareTime);\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function () {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function () {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function () {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter; // loop through each iterator\n\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last; // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n\n        if (iter.completed) {\n          len--;\n\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n\n          iters.splice(iterIdx, 1);\n          continue;\n        } // find the most recent possible choice\n\n\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      } // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n\n\n      return chosenIter;\n    }\n  };\n  return RecurExpansion;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Event = function () {\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function (event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function (obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString(); // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n\n      this.exceptions[id] = obj; // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n\n      if (obj.modifiesFuture()) {\n        var item = [obj.recurrenceId.toUnixTime(), id]; // we keep them sorted so we can find the nearest\n        // value later on...\n\n        var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, item, compareRangeException);\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function () {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function (time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, [utc], compareRangeException);\n      idx -= 1; // occurs before\n\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n      /* istanbul ignore next: sanity check only */\n\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function (occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(occurrence);\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId]; // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n\n          result.item = exception;\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone(); // zones must be same otherwise subtract may be incorrect.\n\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n          end = start.clone();\n          end.addDuration(exception.duration);\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function (startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function () {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function () {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function () {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n\n      if (!endDate) {\n        var duration = this._firstProp('duration');\n\n        endDate = this.startDate.clone();\n\n        if (duration) {\n          endDate.addDuration(duration);\n        } else if (endDate.isDate) {\n          endDate.day += 1;\n        }\n      }\n\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n\n      this._setTime('dtend', value);\n    },\n\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n\n    set color(value) {\n      this._setProp('color', value);\n    },\n\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function (propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      } // utc and local don't get a tzid\n\n\n      if (time.zone === ICAL.Timezone.localTimezone || time.zone === ICAL.Timezone.utcTimezone) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n    _setProp: function (name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n    _firstProp: function (name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function () {\n      return this.component.toString();\n    }\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.ComponentParser = function () {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof options === 'undefined') {\n      options = {};\n    }\n\n    var key;\n\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete:\n    /* istanbul ignore next */\n    function () {},\n\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror:\n    /* istanbul ignore next */\n    function (err) {},\n\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone:\n    /* istanbul ignore next */\n    function (component) {},\n\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent:\n    /* istanbul ignore next */\n    function (component) {},\n\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function (ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof ical === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n\n            break;\n\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n\n            break;\n\n          default:\n            continue;\n        }\n      } //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n\n\n      this.oncomplete();\n    }\n  };\n  return ComponentParser;\n}();","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/ical.js/build/ical.js"],"names":["ICAL","module","exports","HTMLScriptElement","prototype","window","foldLength","newLineChar","helpers","updateTimezones","vcal","allsubs","properties","vtimezones","reqTzid","i","tzid","name","getAllSubcomponents","length","getFirstProperty","getFirstValue","concat","getAllProperties","getParameter","hasOwnProperty","removeSubcomponent","TimezoneService","has","addSubcomponent","get","component","isStrictlyNaN","number","isNaN","strictParseInt","string","result","parseInt","Error","formatClassType","data","type","undefined","unescapedIndexOf","buffer","search","pos","indexOf","binsearchInsert","list","seekVal","cmpfunc","low","high","mid","cmpval","Math","floor","dumpn","debug","console","consoleDumpn","input","log","geckoDumpn","dump","arguments","clone","aSrc","aDeep","Date","getTime","Array","isArray","arr","push","obj","Object","call","foldline","aLine","line","line_length","cp","codePointAt","substring","substr","pad2","pad","String","len","trunc","ceil","inherits","base","child","extra","F","extend","source","target","key","descr","getOwnPropertyDescriptor","defineProperty","design","FROM_ICAL_NEWLINE","TO_ICAL_NEWLINE","FROM_VCARD_NEWLINE","TO_VCARD_NEWLINE","createTextType","fromNewline","toNewline","matches","fromICAL","aValue","structuredEscape","replaceNewline","toICAL","regEx","RegExp","replace","str","DEFAULT_TYPE_TEXT","defaultType","DEFAULT_TYPE_TEXT_MULTI","multiValue","DEFAULT_TYPE_TEXT_STRUCTURED","structuredValue","DEFAULT_TYPE_INTEGER","DEFAULT_TYPE_DATETIME_DATE","allowedTypes","DEFAULT_TYPE_DATETIME","DEFAULT_TYPE_URI","DEFAULT_TYPE_UTCOFFSET","DEFAULT_TYPE_RECUR","DEFAULT_TYPE_DATE_ANDOR_TIME","replaceNewlineReplace","value","newline","commonProperties","commonValues","values","float","parsed","parseFloat","integer","decorate","UtcOffset","fromString","undecorate","toString","icalParams","allowXName","allowIanaToken","valueType","multiValueSeparateDQuote","icalValues","text","uri","aString","Binary","aBinary","aProp","strict","Time","fromDateString","date","fromDateTimeString","duration","Duration","period","parts","split","isValueString","join","Period","fromJSON","toJSON","recur","Recur","_stringToData","k","val","numericDayToIcalDay","toUpperCase","fromData","aRecur","time","icalProperties","detectType","vcardValues","VCardTime","fromDateAndOrTimeString","splitzone","_splitZone","zone","isFromIcal","lastChar","signChar","sign","timestamp","vcardParams","vcardProperties","vcard3Values","binary","vcard","vcard3Params","vcard3Properties","fn","n","nickname","photo","bday","adr","label","tel","email","mailer","tz","geo","title","role","logo","agent","org","note","prodid","rev","sound","class","icalSet","param","property","vcardSet","vcard3Set","defaultSet","components","vcard3","vevent","vtodo","vjournal","valarm","vtimezone","daylight","standard","icalendar","getDesignSet","componentName","isInDesign","stringify","LINE_ENDING","DEFAULT_VALUE_TYPE","jCal","designSet","props","propIdx","propLen","designSetName","comps","compIdx","compLen","noFold","jsName","params","paramName","map","_rfc6868Unescape","propertyValue","propDetails","isDefault","slice","delim","innerMulti","x","RFC6868_REPLACE_MAP","parse","CHAR","MULTIVALUE_DELIMITER","VALUE_DELIMITER","PARAM_DELIMITER","PARAM_NAME_DELIMITER","DEFAULT_PARAM_TYPE","ParserError","message","e","stack","shift","parser","state","root","_eachLine","err","_handleContentLine","valuePos","paramPos","lastParamIndex","lastValuePos","parsedParams","toLowerCase","_parseParameters","newComponent","pop","propertyDetails","_parseMultiValue","_parseValue","start","lastParam","lcname","mvdelim","_rfc6868Escape","nextChar","extendedValue","nextPos","propValuePos","delimiter","lastPos","callback","firstChar","newlineOffset","trim","Component","PROPERTY_INDEX","COMPONENT_INDEX","NAME_INDEX","parent","_hydratedPropertyCount","_hydratedComponentCount","_designSet","parentDesign","_hydrateComponent","index","_components","comp","_hydrateProperty","_properties","prop","Property","getFirstSubcomponent","jCalLen","hasProperty","getFirstPropertyValue","_removeObjectByIndex","jCalIndex","cache","splice","_removeObject","nameOrObject","objects","cached","_removeAllObjects","idx","nameOrComp","removed","removeAllSubcomponents","addProperty","TypeError","removeProperty","addPropertyWithValue","setValue","updatePropertyWithValue","nameOrProp","removeAllProperties","PROP_INDEX","TYPE_INDEX","VALUE_INDEX","_parent","getDefaultType","_updateType","p","designSetChanged","designType","isDecorated","isMultiValue","isStructuredValue","_hydrateValue","_values","_decorate","_undecorate","_setDecoratedValue","getFirstParameter","parameters","setParameter","removeParameter","details","resetType","removeAllValues","getValues","setValues","icaltype","toICALString","aData","hours","minutes","factor","fromSeconds","toSeconds","_normalize","aSeconds","secs","abs","compare","icaltime_compare","other","a","b","options","instance","decodeValue","_b64_decode","setEncodedValue","_b64_encode","base64_encode","b64","o1","o2","o3","h1","h2","h3","h4","bits","ac","enc","tmp_arr","charCodeAt","charAt","r","base64_decode","dec","fromCharCode","icalperiod","wrappedJSObject","end","icalclass","getDuration","subtractDate","getEnd","addDuration","aLenient","fromDateOrDateTimeString","DURATION_LETTERS","icalduration","weeks","days","seconds","isNegative","propsToCopy","reset","aOther","thisSeconds","otherSeconds","normalize","icalduration_from_seconds","parseDurationChunk","letter","object","num","icalduration_from_string","aStr","dict","create","chunks","numeric","icalduration_from_data","OPTIONS","Timezone","icaltimezone","location","tznames","latitude","longitude","expandedUntilYear","changes","utcOffset","tt","utcTimezone","localTimezone","_ensureCoverage","year","tt_change","month","day","hour","minute","second","change_num","_findNearbyChange","change_num_to_use","step","change","prevUtcOffset","adjust_change","cmp","_compare_change_fn","zone_change","utcOffset_change","tmp_change","prev_zone_change","want_daylight","is_daylight","icaltimezone_find_nearby_change","aYear","_minimumExpansionYear","today","now","changesEndYear","EXTRA_COVERAGE","MAX_YEAR","subcomps","_expandComponent","sort","aComponent","dtstart","convert_tzoffset","offset","init_changes","changebase","rdatekey","rdate","isDate","rrule","until","adjust","iterator","occ","next","icaltimezone_compare_change_fn","convert_time","icaltimezone_convert_time","from_zone","to_zone","icaltimezone_fromData","icaltimezone_adjust_change","zones","count","keys","utc","Z","UTC","GMT","register","timezone","remove","icaltime","_time","_dowCache","_wnCache","_cachedUnixTime","_pendingNormalization","icaltime_reset","epochTime","resetTo","icaltime_resetTo","fromJSDate","icaltime_fromJSDate","aDate","useUTC","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","aZone","dayOfWeek","icaltime_dayOfWeek","aWeekStart","firstDow","SUNDAY","dowCacheKey","q","m","Y","h","dayOfYear","is_leap","isLeapYear","diypm","daysInYearPassedMonth","startOfWeek","endOfWeek","startOfMonth","endOfMonth","daysInMonth","startOfYear","endOfYear","startDoyWeek","aFirstDayOfWeek","delta","getDominicalLetter","nthWeekDay","icaltime_nthWeekDay","aDayOfWeek","aPos","weekday","otherDay","startDow","endDow","isNthWeekDay","dow","weekNumber","wnCacheKey","week1","dt","isoyear","weekOneStarts","daysBetween","answer","icaltime_add","aDuration","mult","icaltime_subtract","unixTime","toUnixTime","subtractDateTz","icaltime_subtract_abs","compareDateOnlyTz","icaltime_compareDateOnlyTz","attr","_cmp_attr","convertToZone","rc","copy","zone_equals","utc_offset","toJSDate","icaltime_normalize","icaltime_adjust","aExtraDays","aExtraHours","aExtraMinutes","aExtraSeconds","aTime","minutesOverflow","hoursOverflow","daysOverflow","yearsOverflow","fromUnixTime","epoch","ms","setupNormalizeAttributes","defineAttr","getTimeAttr","set","setTimeAttr","icaltime_daysInMonth","_daysInMonth","fromDayOfYear","icaltime_fromDayOfYear","aDayOfYear","doy","auto_normalize","fromStringv2","aProperty","t","icaltime_now","wkst","DEFAULT_WEEK_START","THURSDAY","yr","LTRS","dom","isLeap","MONDAY","TUESDAY","WEDNESDAY","FRIDAY","SATURDAY","apply","p2","y","d","mm","s","hasYear","hasMonth","hasDay","hasHour","hasMinute","hasSecond","datepart","timepart","aIcalType","part","v","tmz","tm","stoi","dtlen","tmlen","hasDashDate","hasDashTime","o","DOW_MAP","SU","MO","TU","WE","TH","FR","SA","REVERSE_DOW_MAP","COPY_PARTS","icalrecur","interval","freq","aStart","RecurIterator","rule","isFinite","isfinite","isByCount","isbycount","addComponent","addPart","aType","ucname","setComponent","aValues","getComponent","getNextOccurrence","aStartTime","aRecurrenceId","iter","cdt","uckey","partDesign","optionDesign","INTERVAL","icalDayToNumericDay","res","kparts","icalrecur_toString","parseNumericValue","min","max","toNumericDay","toIcalDay","VALID_DAY_NAMES","VALID_BYDAY_PART","ALLOWED_FREQ","FREQ","fmtIcal","COUNT","UNTIL","WKST","test","BYSECOND","bind","BYMINUTE","BYHOUR","BYDAY","BYMONTHDAY","BYYEARDAY","BYWEEKNO","BYMONTH","BYSETPOS","partArr","partArrIdx","partArrLen","icalrecur_iterator","completed","last","occurrence_number","by_indices","initialized","by_data","days_index","init","icalrecur_iterator_init","sort_byday_rules","setup_defaults","bydayParts","ruleDayOfWeek","wkdy","dayName","expand_year_days","increment_year","_nextByYearDay","has_by_data","tempLast","initLast","dayOfMonth","increment_month","_byDayAndMonthDay","icalrecur_iterator_next","before","valid","next_second","next_minute","next_hour","next_day","next_week","next_month","next_year","check_contracting_rules","next_generic","increment_second","inc","increment_generic","increment_minute","increment_hour","has_by_day","this_freq","increment_monthday","end_of_data","next_weekday_by_week","week_no","normalizeByMonthDayRules","rules","newRules","ruleIdx","isInit","byMonthDay","byDay","dateIdx","dateLen","dayLen","dataIsValid","self","lastDay","initMonth","nextMonth","monthsCounter","dayIdx","data_valid","setpos","setpos_total","last_day","is_day_in_byday","check_set_position","coded_day","match","aRuleType","aInterval","aDateAttr","aFollowingAttr","aPreviousIncr","has_by_rule","dta","years","aFactor","aNextIncrement","nextunit","validWeeks","monthIdx","first_week","last_week","weekIdx","weekno","partCount","t1","monthkey","t2","monthdaykey","t3","day_","month_","expand_by_day","first_dow","doy_offset","last_dow","set_pos_counter","by_month_day","spIndex","daycodedkey","month_day","first_matching_day","last_matching_day","expandedDays","daykey","days_list","tmp","start_dow","end_dow","end_year_day","tmp_start_doy","first","this_dow","icalrecur_sort_byday_rules","aRules","j","one","two","check_contract_restriction","indexMapValue","_indexMap","ruleMapValue","_expandMap","pass","CONTRACT","ruleType","bydatakey","weekNo","req","deftime","UNKNOWN","EXPAND","ILLEGAL","RecurExpansion","formatTime","item","compareTime","isRecurringComponent","ruleDates","exDates","complete","ruleIterators","ruleDateInc","exDateInc","exDate","ruleDate","_init","ruleOfDay","maxTries","currentTry","_nextRecurrenceIter","_nextRuleDay","_nextExDay","_extractDates","propertyName","handleProp","forEach","iters","iterTime","iterIdx","chosenIter","Event","_rangeExceptionCache","exceptions","rangeExceptions","strictExceptions","relateException","isRecurrenceException","event","THISANDFUTURE","uid","id","recurrenceId","modifiesFuture","compareRangeException","range","findRangeException","rangeItem","getOccurrenceDetails","occurrence","utcId","startDate","endDate","rangeExceptionId","exception","startDiff","original","newStart","startTime","isRecurring","getRecurrenceTypes","_firstProp","_setProp","_setTime","attendees","summary","description","color","organizer","sequence","propName","ComponentParser","parseEvent","parseTimezone","oncomplete","onerror","ontimezone","onevent","process","ical"],"mappings":"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C24B,cAAL,GAAuB,YAAW;AAChC,WAASC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,WAAO74B,IAAI,CAACQ,OAAL,CAAagC,eAAb,CAA6Bq2B,IAA7B,EAAmC74B,IAAI,CAACsK,IAAxC,CAAP;AACD;;AAED,WAASwuB,WAAT,CAAqBzf,CAArB,EAAwBC,CAAxB,EAA2B;AACzB,WAAOD,CAAC,CAACH,OAAF,CAAUI,CAAV,CAAP;AACD;;AAED,WAASyf,oBAAT,CAA8BjkB,IAA9B,EAAoC;AAClC,WAAOA,IAAI,CAACO,WAAL,CAAiB,OAAjB,KACAP,IAAI,CAACO,WAAL,CAAiB,OAAjB,CADA,IAEAP,IAAI,CAACO,WAAL,CAAiB,eAAjB,CAFP;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASsjB,cAAT,CAAwBpf,OAAxB,EAAiC;AAC/B,SAAKyf,SAAL,GAAiB,EAAjB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKttB,QAAL,CAAc4N,OAAd;AACD;;AAEDof,EAAAA,cAAc,CAACv4B,SAAf,GAA2B;AACzB;AACJ;AACA;AACA;AACI84B,IAAAA,QAAQ,EAAE,KALe;;AAOzB;AACJ;AACA;AACA;AACA;AACA;AACIC,IAAAA,aAAa,EAAE,IAbU;;AAezB;AACJ;AACA;AACA;AACA;AACA;AACIH,IAAAA,SAAS,EAAE,IArBc;;AAuBzB;AACJ;AACA;AACA;AACA;AACA;AACIC,IAAAA,OAAO,EAAE,IA7BgB;;AA+BzB;AACJ;AACA;AACA;AACA;AACIG,IAAAA,WAAW,EAAE,CApCY;;AAsCzB;AACJ;AACA;AACA;AACA;AACIC,IAAAA,SAAS,EAAE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","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n(function() {\n  /* istanbul ignore next */\n  if (typeof module === 'object') {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else if (typeof HTMLScriptElement !== 'undefined' && 'noModule' in HTMLScriptElement.prototype) {\n    // Until we use ES6 exports, using <script type=\"module\"> we define ICAL on the window global.\n    window.ICAL = ICAL = {};\n  } else if (typeof ICAL !== 'object') {\n    ICAL = {};\n  }\n})();\n/* jshint ignore:end */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\nICAL.foldLength = 75;\n\n\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\nICAL.newLineChar = '\\r\\n';\n\n\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function(vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    }\n\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    }\n\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for (i = 0; i < properties.length; i++) {\n      if ((tzid = properties[i].getParameter(\"tzid\"))) {\n        reqTzid[tzid] = true;\n      }\n    }\n\n    //delete any vtimezones that are not on the reqTzid list.\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    }\n\n    //create any missing, but registered timezones\n    for (i in reqTzid) {\n      if (\n        reqTzid.hasOwnProperty(i) &&\n        !vtimezones[i] &&\n        ICAL.TimezoneService.has(i)\n      ) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function(number) {\n    return typeof(number) === 'number' && isNaN(number);\n  },\n\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function(string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error(\n        'Could not extract integer from \"' + string + '\"'\n      );\n    }\n\n    return result;\n  },\n\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof(data) === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n    return new type(data);\n  },\n\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function(buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function(list, seekVal, cmpfunc) {\n    if (!list.length)\n      return 0;\n\n    var low = 0, high = list.length - 1,\n        mid, cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n\n      if (cmpval < 0)\n        high = mid - 1;\n      else if (cmpval > 0)\n        low = mid + 1;\n      else\n        break;\n    }\n\n    if (cmpval < 0)\n      return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0)\n      return mid + 1;\n    else\n      return mid;\n  },\n\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn: /* istanbul ignore next */ function() {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof (console) !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n      return arr;\n    } else {\n      var obj = {};\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n      return obj;\n    }\n  },\n\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\", pos = 0, line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;\n      else if (cp < 2048) line_length += 2;//needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;\n      else line_length += 4; //cp is less than 1114112\n      if (line_length < ICAL.foldLength + 1)\n        pos += cp > 65535 ? 2 : 1;\n      else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof(data) !== 'string') {\n      // handle fractions.\n      if (typeof(data) === 'number') {\n        data = parseInt(data);\n      }\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n      case 1:\n        return '0' + data;\n      default:\n        return data;\n    }\n  },\n\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return (number < 0 ? Math.ceil(number) : Math.floor(number));\n  },\n\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function(base, child, extra) {\n    function F() {}\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function(source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.design = (function() {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n\n      fromICAL: function(aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n\n      toICAL: function(aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape)\n          regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function(str) {\n          switch (str) {\n          case \"\\\\\":\n            return \"\\\\\\\\\";\n          case \";\":\n            return \"\\\\;\";\n          case \",\":\n            return \"\\\\,\";\n          case \"\\n\":\n            return \"\\\\n\";\n          /* istanbul ignore next */\n          default:\n            return str;\n          }\n        });\n      }\n    };\n    return result;\n  }\n\n  // default types used multiple times\n  var DEFAULT_TYPE_TEXT = { defaultType: \"text\" };\n  var DEFAULT_TYPE_TEXT_MULTI = { defaultType: \"text\", multiValue: \",\" };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: \"text\", structuredValue: \";\" };\n  var DEFAULT_TYPE_INTEGER = { defaultType: \"integer\" };\n  var DEFAULT_TYPE_DATETIME_DATE = { defaultType: \"date-time\", allowedTypes: [\"date-time\", \"date\"] };\n  var DEFAULT_TYPE_DATETIME = { defaultType: \"date-time\" };\n  var DEFAULT_TYPE_URI = { defaultType: \"uri\" };\n  var DEFAULT_TYPE_UTCOFFSET = { defaultType: \"utc-offset\" };\n  var DEFAULT_TYPE_RECUR = { defaultType: \"recur\" };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: \"date-and-or-time\", allowedTypes: [\"date-time\", \"date\", \"text\"] };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n      case \"\\\\;\":\n        return \";\";\n      case \"\\\\,\":\n        return \",\";\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n      /* istanbul ignore next */\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n    if (structuredEscape)\n      newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n\n      fromICAL: function(aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n          case 'FALSE':\n            return false;\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n\n      toICAL: function(aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n        return 'FALSE';\n      }\n\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n\n      fromICAL: function(aValue) {\n        var parsed = parseFloat(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function(aValue) {\n        var parsed = parseInt(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2) +\n                 aValue.substr(7, 2);\n        }\n      },\n\n      fromICAL: function(aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2) + ':' +\n                 aValue.substr(5, 2);\n        }\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n\n    // CN just wants a param-value\n    // \"CN\": { ... }\n\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\",\n               \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\",\n               \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\",\n               \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\",\n               \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n\n    uri: {\n      // TODO\n      /* ... */\n    },\n\n    \"binary\": {\n      decorate: function(aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n\n      undecorate: function(aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {\n      // needs to be an uri\n    },\n    \"date\": {\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' +\n                 aValue.substr(4, 2) + '-' +\n                 aValue.substr(6, 2);\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) +\n                 aValue.substr(5, 2) +\n                 aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n\n      }\n    },\n    \"date-time\": {\n      fromICAL: function(aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' +\n                       aValue.substr(4, 2) + '-' +\n                       aValue.substr(6, 2) + 'T' +\n                       aValue.substr(9, 2) + ':' +\n                       aValue.substr(11, 2) + ':' +\n                       aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) +\n                       aValue.substr(5, 2) +\n                       // grab the (DDTHH) segment\n                       aValue.substr(8, 5) +\n                       // MM\n                       aValue.substr(14, 2) +\n                       // SS\n                       aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function(aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n\n      fromICAL: function(string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n\n      toICAL: function(parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n\n      decorate: function(aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function(string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n\n      toICAL: function(data) {\n        var str = \"\";\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n          var val = data[k];\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n        return str.substr(0, str.length - 1);\n      },\n\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n\n      undecorate: function(aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n\n    time: {\n      fromICAL: function(aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        }\n\n        // HH::MM::SSZ?\n        var result = aValue.substr(0, 2) + ':' +\n                     aValue.substr(2, 2) + ':' +\n                     aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n\n      toICAL: function(aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) +\n                     aValue.substr(3, 2) +\n                     aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": { defaultType: \"uri\" },\n    \"attendee\": { defaultType: \"cal-address\" },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": { defaultType: \"duration\" },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": { defaultType: \"period\", multiValue: \",\" },\n    \"geo\": { defaultType: \"float\", structuredValue: \";\" },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": { defaultType: \"cal-address\" },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function(string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": { defaultType: \"duration\", allowedTypes: [\"duration\", \"date-time\"] },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  });\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n\n    date: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function(aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n\n    time: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n        var zone = splitzone[0], value = splitzone[1];\n\n        //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' +\n                  value.substr(2, 2) + ':' +\n                  value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n\n      toICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n        var zone = splitzone[0], value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) +\n                  value.substr(3, 2) +\n                  value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n\n      _splitZone: function(aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n\n    \"date-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n\n      toICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n\n    \"date-and-or-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +\n               (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n\n      toICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) +\n               (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    }\n  });\n\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\",\n               \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\",\n               \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": { defaultType: \"language-tag\" },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": { defaultType: \"text\", structuredValue: \";\" },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": { defaultType: \"timestamp\" },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": { defaultType: \"uri\", allowedTypes: [\"uri\", \"text\"] },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": { defaultType: \"text\", allowedTypes: [\"text\", \"utc-offset\", \"uri\"] },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {\n      // TODO\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      fromICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\",\n               \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n\n    adr: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    label: DEFAULT_TYPE_TEXT,\n\n    tel: { defaultType: \"phone-number\" },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n\n    tz: { defaultType: \"utc-offset\", allowedTypes: [\"utc-offset\", \"text\"] },\n    geo: { defaultType: \"float\", structuredValue: \";\" },\n\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    agent: { defaultType: \"vcard\", allowedTypes: [\"vcard\", \"text\", \"uri\"] },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n\n    class: DEFAULT_TYPE_TEXT,\n    key: { defaultType: \"binary\", allowedTypes: [\"binary\", \"text\"] }\n  });\n\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function(componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n\n  return design;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\nICAL.stringify = (function() {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.component = function(component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n\n    var designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === 'vcard' && component[1].length > 0 &&\n            !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.property = function(property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n\n    var line = name;\n\n    var paramName;\n    for (paramName in params) {\n      var value = params[paramName];\n\n      /* istanbul ignore else */\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if (('structuredValue' in propDetails) && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    }\n\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, multiValue, designSet, structuredValue\n      );\n    } else if (multiValue) {\n      line += stringify.multiValue(\n        property.slice(3), multiValue, valueType, null, designSet, false\n      );\n    } else if (structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, null, designSet, structuredValue\n      );\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n  stringify.propertyValue = function(value) {\n\n    if ((helpers.unescapedIndexOf(value, ',') === -1) &&\n        (helpers.unescapedIndexOf(value, ':') === -1) &&\n        (helpers.unescapedIndexOf(value, ';') === -1)) {\n\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n  stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== (len - 1)) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n  stringify.value = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n  stringify._rfc6868Unescape = function(val) {\n    return val.replace(/[\\n^\"]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { '\"': \"^'\", \"\\n\": \"^n\", \"^\": \"^^\" };\n\n  return stringify;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\nICAL.parse = (function() {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n\n    state.stack = [root];\n\n    parser._eachLine(input, function(err, line) {\n      parser._handleContentLine(line, state);\n    });\n\n\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n      throw new ParserError(\n        'invalid ical body. component began but did not end'\n      );\n    }\n\n    state = null;\n\n    return (root.length == 1 ? root[0] : root);\n  }\n\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n  parser.property = function(str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n    parser._handleContentLine(str, state);\n    return state.component[1][0];\n  };\n\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n  parser.component = function(str) {\n    return parser(str);\n  };\n\n  // classes & constants\n  parser.ParserError = ParserError;\n\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n  parser._handleContentLine = function(line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n\n    var lastParamIndex;\n    var lastValuePos;\n\n    // name of property or begin/end\n    var name;\n    var value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    var params = {};\n\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n\n    if ((paramPos !== -1 && valuePos !== -1)) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n      if ((lastValuePos =\n        line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n        state.stack.push(state.component);\n        state.component = newComponent;\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      }\n      // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError(\n        'invalid line (no token \";\" or \":\") \"' + line + '\"'\n      );\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    }\n\n    // attempt to determine value\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 &&\n            !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n  };\n\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n  parser._parseValue = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n  parser._parseParameters = function(line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value, valuePos = -1;\n    var type, multiValue, mvdelim;\n\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while ((pos !== false) &&\n           (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n        if (multiValue && pos != -1) {\n            var extendedValue = true;\n            while (extendedValue) {\n              if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n              } else {\n                extendedValue = false;\n              }\n            }\n          }\n        if (pos === -1) {\n          throw new ParserError(\n            'invalid line (no matching double quote) \"' + line + '\"'\n          );\n        }\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1;\n\n        // move to next \";\"\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && (lcname in result)) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [\n            result[lcname],\n            value\n          ];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n    return [result, value, valuePos];\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n  parser._rfc6868Escape = function(val) {\n    return val.replace(/\\^['n^]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { \"^'\": '\"', \"^n\": \"\\n\", \"^^\": \"^\" };\n\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n  parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n    if (delim.length === 0) {\n      return buffer;\n    }\n\n    // split each piece\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n      result.push(value);\n      lastPos = pos + delim.length;\n    }\n\n    // on the last piece take the rest of string\n    value = buffer.substr(lastPos);\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n\n    return result.length == 1 ? result[0] : result;\n  };\n\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n  parser._eachLine = function(buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(\n          lastPos + 1,\n          pos - lastPos - (newlineOffset + 1)\n        );\n      } else {\n        if (line)\n          callback(null, line);\n        // push line\n        line = buffer.substr(\n          lastPos,\n          pos - lastPos - newlineOffset\n        );\n      }\n\n      lastPos = pos;\n    } while (pos !== len);\n\n    // extra ending line\n    line = line.trim();\n\n    if (line.length)\n      callback(null, line);\n  };\n\n  return parser;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Component = (function() {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n  function Component(jCal, parent) {\n    if (typeof(jCal) === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function(index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(\n        this.jCal[COMPONENT_INDEX][index],\n        this\n      );\n\n      this._hydratedComponentCount++;\n      return (this._components[index] = comp);\n    },\n\n    _hydrateProperty: function(index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(\n        this.jCal[PROPERTY_INDEX][index],\n        this\n      );\n\n      this._hydratedPropertyCount++;\n      return (this._properties[index] = prop);\n    },\n\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function(name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      }\n\n      // ensure we return a value (strict mode)\n      return null;\n    },\n\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function(name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateComponent(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._components ||\n            (this._hydratedComponentCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function(name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n\n      var i = 0;\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function(name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function(name) {\n      var prop = this.getFirstProperty(name);\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function(name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateProperty(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._properties ||\n            (this._hydratedPropertyCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n\n    _removeObjectByIndex: function(jCalIndex, cache, index) {\n      cache = cache || [];\n      // remove cached version\n      if (cache[index]) {\n        var obj = cache[index];\n        if (\"parent\" in obj) {\n            obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1);\n\n      // remove it from the jCal\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n\n    _removeObject: function(jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof(nameOrObject) === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    _removeAllObjects: function(jCalIndex, cache, name) {\n      var cached = this[cache];\n\n      // Unfortunately we have to run through all children to reset their\n      // parent property.\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1;\n\n      // descending search required because splice\n      // is used and will effect the indices.\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function(component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function(nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function(name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function(property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function(name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n\n      this.addProperty(prop);\n\n      return prop;\n    },\n\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function(name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function(nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function(name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function() {\n      return ICAL.stringify.component(\n        this.jCal, this._designSet\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n  Component.fromString = function(str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Property = (function() {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n\n  var design = ICAL.design;\n\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof(jCal) === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n    this._updateType();\n  }\n\n  Property.prototype = {\n\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);\n\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function() {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = ('multiValue' in designSet.property[this.name]);\n          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);\n        }\n      }\n    },\n\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function(index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      }\n\n      // for the case where there is no value.\n      if (this.jCal.length <= (VALUE_INDEX + index)) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n        return (this._values[index] = this._decorate(\n          this.jCal[VALUE_INDEX + index]\n        ));\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function(value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function(value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function(value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function(name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function(name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function(name, value) {\n      var lcname = name.toLowerCase();\n      if (typeof value === \"string\" &&\n          lcname in this._designSet.param &&\n          'multiValue' in this._designSet.param[lcname]) {\n          value = [value];\n      }\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function(name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function() {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n      return design.defaultType;\n    },\n\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function(type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n      this._updateType();\n    },\n\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function() {\n      return this._hydrateValue(0);\n    },\n\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function() {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function() {\n      if (this._values) {\n        this._values.length = 0;\n      }\n      this.jCal.length = 3;\n    },\n\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function(values) {\n      if (!this.isMultiValue) {\n        throw new Error(\n          this.name + ': does not not support mulitValue.\\n' +\n          'override isMultiValue'\n        );\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 &&\n          typeof(values[0]) === 'object' &&\n          'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function(value) {\n      this.removeAllValues();\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.stringify.property(\n        this.jCal, this._designSet, true\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n  Property.fromString = function(str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.UtcOffset = (function() {\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function() {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function(aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n      this._normalize();\n    },\n\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n\n      secs -= (this.hours * 3600);\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function() {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n\n    _normalize: function() {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n      while (secs < -43200) { // = UTC-12:00\n        secs += 97200;\n      }\n      while (secs > 50400) { // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs);\n\n      // Avoid changing the factor when on zero seconds\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") +\n              ICAL.helpers.pad2(this.hours) + ':' +\n              ICAL.helpers.pad2(this.minutes);\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n  UtcOffset.fromString = function(aString) {\n    // -05:00\n    var options = {};\n    //TODO: support seconds per rfc5545 ?\n    options.factor = (aString[0] === '+') ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n\n    return new ICAL.UtcOffset(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n  UtcOffset.fromSeconds = function(aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Binary = (function() {\n\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafa Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n\n      var r = data.length % 3;\n\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n\n    },\n\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        dec = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do { // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n\n      return dec;\n    },\n\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function() {\n      return this.value;\n    }\n  };\n\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n  Binary.fromString = function(aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function() {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function() {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.start.toICALString() + \"/\" +\n             (this.end || this.duration).toICALString();\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error(\n        'Invalid string value: \"' + str + '\" must contain a \"/\" char.'\n      );\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromJSON = function(aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +\n                    86400 * this.days + 7 * 86400 * this.weeks;\n      return (this.isNegative ? -seconds : seconds);\n    },\n\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.isNegative = (aSeconds < 0);\n      this.days = ICAL.helpers.trunc(secs / 86400);\n\n      // If we have a flat number of weeks, use them.\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\",\n                         \"minutes\", \"seconds\", \"isNegative\"];\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n        var prop = propsToCopy[key];\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n        return str;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.toString();\n    }\n  };\n\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return (new ICAL.Duration()).fromSeconds(aSeconds);\n  };\n\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n  function parseDurationChunk(letter, number, object) {\n    var type;\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        }\n        // period\n        break;\n      case 'D':\n        type = 'days';\n        break;\n      case 'W':\n        type = 'weeks';\n        break;\n      case 'H':\n        type = 'hours';\n        break;\n      case 'M':\n        type = 'minutes';\n        break;\n      case 'S':\n        type = 'seconds';\n        break;\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error(\n          'invalid duration value: Missing number before \"' + letter + '\"'\n        );\n      }\n      var num = parseInt(number, 10);\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error(\n          'invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"'\n        );\n      }\n      object[type] = num;\n    }\n\n    return 1;\n  }\n\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n  ICAL.Duration.isValueString = function(string) {\n    return (string[0] === 'P' || string[1] === 'P');\n  };\n\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error(\n        'invalid duration value: Not enough duration components in \"' + aStr + '\"'\n      );\n    }\n\n    return new ICAL.Duration(dict);\n  };\n\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n\n(function() {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\",\n                 \"latitude\", \"longitude\"];\n\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        }\n\n        // Copy remaining passed properties\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      }\n\n      // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n      var change_num_to_use = -1;\n      var step = 1;\n\n      // TODO: replace with bin search?\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                          change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,\n                                        tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight &&\n              prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      }\n\n      // TODO return is_daylight?\n      return zone_change.utcOffset;\n    },\n\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(\n        this.changes,\n        change,\n        ICAL.Timezone._compare_change_fn\n      );\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n\n    _ensureCoverage: function(aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(\n            subcomps[compIdx], changesEndYear, this.changes\n          );\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n\n    _expandComponent: function(aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") ||\n          !aComponent.hasProperty(\"tzoffsetto\") ||\n          !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = (aComponent.name == \"daylight\");\n        changebase.utcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue()\n        );\n\n        changebase.prevUtcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue()\n        );\n\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n\n        ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                        -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n\n          var occ;\n          while ((occ = iterator.next())) {\n            change = init_changes();\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n\n            ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                            -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.tznames ? this.tznames : this.tzid);\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;\n    else if (a.year > b.year) return 1;\n\n    if (a.month < b.month) return -1;\n    else if (a.month > b.month) return 1;\n\n    if (a.day < b.day) return -1;\n    else if (a.day > b.day) return 1;\n\n    if (a.hour < b.hour) return -1;\n    else if (a.hour > b.hour) return 1;\n\n    if (a.minute < b.minute) return -1;\n    else if (a.minute > b.minute) return 1;\n\n    if (a.second < b.second) return -1;\n    else if (a.second > b.second) return 1;\n\n    return 0;\n  };\n\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate ||\n        from_zone.tzid == to_zone.tzid ||\n        from_zone == ICAL.Timezone.localTimezone ||\n        to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, - utcOffset);\n\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n\n    return null;\n  };\n\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(\n      change,\n      days,\n      hours,\n      minutes,\n      seconds,\n      change\n    );\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.TimezoneService = (function() {\n  var zones;\n\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function() {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function(tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function(tzid) {\n      return zones[tzid];\n    },\n\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function(name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function(tzid) {\n      return (delete zones[tzid]);\n    }\n  };\n\n  // initialize defaults\n  TimezoneService.reset();\n\n  return TimezoneService;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    /* time defaults */\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n\n  ICAL.Time.prototype = {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function() {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day,\n                                       hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && (\"isDate\" in aData)) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(\n          aData.timezone\n        );\n\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      }\n\n      // Using Zeller's algorithm\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n\n      var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));\n      /* istanbul ignore else */\n      if (true /* gregorian */) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      }\n\n      // Normalize to 1 = wkst\n      h = ((h + 7 - firstDow) % 7) + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function() {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n\n      var start = 0;\n\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1;\n\n        // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        }\n\n        // set current start offset to current day.\n        start = otherDay.day;\n\n        // find the current day of week\n        var startDow = otherDay.dayOfWeek();\n\n        // calculate the difference between current\n        // day of the week and desired day of the week\n        var offset = aDayOfWeek - startDow;\n\n\n        // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n        if (offset < 0)\n          // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7;\n\n        // add offset to start so start is the same\n        // day of the week as the desired day of week.\n        start += offset;\n\n        // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n        start -= aDayOfWeek;\n\n        // set week day\n        weekday = aDayOfWeek;\n      } else {\n\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth;\n\n        // find the ends weekday\n        var endDow = otherDay.dayOfWeek();\n\n        pos++;\n\n        weekday = (endDow - aDayOfWeek);\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n\n      return start + weekday;\n    },\n\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function(aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      }\n\n      // get pos\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      }\n      // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n      var week1;\n\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = (aDuration.isNegative ? -1 : 1);\n\n      // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n\n      return rc;\n    },\n\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = (this.zone.tzid == zone.tzid);\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone ||\n          this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function() {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' +\n                   ICAL.helpers.pad2(this.month) + '-' +\n                   ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n          result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +\n                    ICAL.helpers.pad2(this.minute) + ':' +\n                    ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day,\n                          this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n      this.adjust(0, 0, 0, 0);\n\n      return this;\n    },\n\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours,\n                                     aExtraMinutes, aExtraSeconds, aTime) {\n\n      var minutesOverflow, hoursOverflow,\n          daysOverflow = 0, yearsOverflow = 0;\n\n      var second, minute, hour, day;\n      var daysInMonth;\n\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      }\n\n\n      // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow;\n\n      // Now take care of the days (and adjust month if needed)\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n      var offset = this.utcOffset();\n\n      // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n      var ms = Date.UTC(\n        this.year,\n        this.month - 1,\n        this.day,\n        this.hour,\n        this.minute,\n        this.second - offset\n      );\n\n      // seconds\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function() {\n      var copy = [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'isDate'\n      ];\n\n      var result = Object.create(null);\n\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n\n          return val;\n        }\n      });\n\n    }\n\n    /* istanbul ignore else */\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n\n    if (month < 1 || month > 12) return days;\n\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return ((year % 4) == 0);\n    } else {\n      return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));\n    }\n  };\n\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n\n    if (doy < 1) {\n      year--;\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromDateString = function(aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromDateTimeString = function(aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error(\n        'invalid date-time value: \"' + aValue + '\"'\n      );\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    }\n\n    // 2012-10-10T10:10:10(Z)?\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n\n    return time;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is floating - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n\n    return t;\n  };\n\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n  ICAL.Time.getDominicalLetter = function(yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n  ICAL.Time.daysInYearPassedMonth = [\n    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],\n    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\n  ];\n\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n\n(function() {\n\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function(data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n\n    this.icaltype = icaltype || \"date-and-or-time\";\n\n    this.fromData(data, zone);\n  };\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function() {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n\n    _normalize: function() {\n      return this;\n    },\n\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function() {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function() {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year, m = this.month, d = this.day;\n      var h = this.hour, mm = this.minute, s = this.second;\n\n      var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n      var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +\n                     (hasMonth ? p2(m) : '') +\n                     (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +\n                     (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +\n                     (hasMinute && hasSecond ? ':' : '') +\n                     (hasSecond ? p2(s) : '');\n\n      var zone;\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n        case \"date\":\n          return datepart;\n      }\n      return null;\n    }\n  });\n\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n  ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n    var parts = aValue.split('T');\n    var dt = parts[0], tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0], tm = splitzone[1];\n\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n\n  var REVERSE_DOW_MAP = {};\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\",\n                    \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\",\n                    \"BYMONTH\", \"BYSETPOS\"];\n\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof(data) === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function(aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return (ucname in this.parts ? this.parts[ucname].slice() : []);\n    },\n\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function(data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n        var kparts = this.parts[k];\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return res;\n    },\n\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be > ' + min\n      );\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be < ' + min\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;\n  };\n\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = (num + firstDow - ICAL.Time.SUNDAY);\n    if (dow > 7) {\n      dow -= 7;\n    }\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',\n                      'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n\n  var optionDesign = {\n    FREQ: function(value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error(\n          'invalid frequency \"' + value + '\" expected: \"' +\n          ALLOWED_FREQ.join(', ') + '\"'\n        );\n      }\n    },\n\n    COUNT: function(value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n\n    INTERVAL: function(value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n\n    UNTIL: function(value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n\n    WKST: function(value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function(value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n  ICAL.Recur.fromString = function(string) {\n    var data = ICAL.Recur._stringToData(string, false);\n    return new ICAL.Recur(data);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n  ICAL.Recur.fromData = function(aData) {\n    return new ICAL.Recur(aData);\n  };\n\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n  ICAL.Recur._stringToData = function(string, fmtIcal) {\n    var dict = Object.create(null);\n\n    // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = (fmtIcal ? lcname : ucname);\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n        dict[name] = (partArr.length == 1 ? partArr[0] : partArr);\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurIterator = (function() {\n\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function(options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number)\n        this.occurrence_number = options.occurrence_number;\n\n      this.days = options.days || [];\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      }\n\n      // If the BYYEARDAY appares, no other date rule part may appear\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts ||\n            \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      }\n\n      // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      }\n\n      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n      if (this.rule.freq == \"MONTHLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      }\n\n      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n      if (this.rule.freq == \"WEEKLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      }\n\n      // BYYEARDAY may only appear in YEARLY rules\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n          if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n          if (this.days.length > 0) {\n            break;\n          }\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        // Check every weekday in BYDAY with relative dow and pos.\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos);\n\n          // If |pos| >= 6, the byday is invalid for a monthly rule.\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          }\n\n          // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n        this.last = tempLast.clone();\n\n        //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n\n    },\n\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = (this.last ? this.last.clone() : null);\n\n      if ((this.rule.count && this.occurrence_number >= this.rule.count) ||\n          (this.rule.until && this.last.compare(this.rule.until) > 0)) {\n\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n\n      var valid;\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n        case \"SECONDLY\":\n          this.next_second();\n          break;\n        case \"MINUTELY\":\n          this.next_minute();\n          break;\n        case \"HOURLY\":\n          this.next_hour();\n          break;\n        case \"DAILY\":\n          this.next_day();\n          break;\n        case \"WEEKLY\":\n          this.next_week();\n          break;\n        case \"MONTHLY\":\n          valid = this.next_month();\n          break;\n        case \"YEARLY\":\n          this.next_year();\n          break;\n\n        default:\n          return null;\n        }\n      } while (!this.check_contracting_rules() ||\n               this.last.compare(this.dtstart) < 0 ||\n               !valid);\n\n      // TODO is this valid?\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" +\n                        \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\",\n                               \"minute\", \"hour\", \"next_second\");\n    },\n\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\",\n                               \"monthday\", \"next_minute\");\n    },\n\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = (this.rule.freq == \"DAILY\");\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        }\n\n        // HACK should be first month of the year\n        this.last.month = 1;\n        this.last.day = 1;\n\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function(year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year);\n\n      // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n      var newRules = [];\n\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx];\n\n        // if this rule falls outside of given\n        // month discard it.\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        }\n\n        // negative case\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        }\n\n        // only add unique items...\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n\n      }\n\n      // unique and sort\n      return newRules.sort(function(a, b) { return a - b; });\n    },\n\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function(isInit) {\n      var byMonthDay; // setup in initMonth\n      var byDay = this.by_data.BYDAY;\n\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n      var dayLen = byDay.length;\n\n      // we are not valid by default\n      var dataIsValid = 0;\n\n      var daysInMonth;\n      var self = this;\n      // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(\n          self.last.month, self.last.year\n        );\n\n        byMonthDay = self.normalizeByMonthDayRules(\n          self.last.year,\n          self.last.month,\n          self.by_data.BYMONTHDAY\n        );\n\n        dateLen = byMonthDay.length;\n\n        // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n        while (byMonthDay[dateIdx] <= lastDay &&\n               !(isInit && byMonthDay[dateIdx] == lastDay) &&\n               dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth();\n\n      // should come after initMonth\n      if (isInit) {\n        lastDay -= 1;\n      }\n\n      // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--;\n        // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        }\n\n        // find next date\n        var next = byMonthDay[dateIdx++];\n\n        // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        }\n\n        // Now we can loop through the day rules to see\n        // if one matches the current month date.\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n\n          this.last.day = lastDay;\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        }\n\n        // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n\n      return dataIsValid;\n    },\n\n    next_month: function next_month() {\n      var this_freq = (this.rule.freq == \"MONTHLY\");\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") ||\n                this.check_set_position(++setpos) ||\n                this.check_set_position(setpos - setpos_total - 1)) {\n\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,\n                                                  this.last.year);\n\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n\n        return end_of_data;\n      }\n    },\n\n    next_year: function next_year() {\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n\n    _nextByYearDay: function _nextByYearDay() {\n        var doy = this.days[this.days_index];\n        var year = this.last.year;\n        if (doy < 1) {\n            // Time.fromDayOfYear(doy, year) indexes relative to the\n            // start of the given year. That is different from the\n            // semantics of BYYEARDAY where negative indexes are an\n            // offset from the end of the given year.\n            doy += 1;\n            year += 1;\n        }\n        var next = ICAL.Time.fromDayOfYear(doy, year);\n        this.last.day = next.day;\n        this.last.month = next.month;\n    },\n\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr,\n                                        aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = (this.rule.freq == aInterval);\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n\n    increment_month: function increment_month() {\n      this.last.day = 1;\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n\n    increment_generic: function increment_generic(inc, aDateAttr,\n                                                  aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n\n    has_by_data: function has_by_data(aRuleType) {\n      return (aRuleType in this.rule.parts);\n    },\n\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = [];\n\n      // We need our own copy with a few keys set\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 2 &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) ||\n                  this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n\n              var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;\n              var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        }\n        // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n        this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&\n              this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n      return 0;\n    },\n\n    expand_by_day: function expand_by_day(aYear) {\n\n      var days_list = [];\n      var tmp = this.last.clone();\n\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n\n      var start_dow = tmp.dayOfWeek();\n\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n\n        } else if (pos > 0) {\n          var first;\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n      return days_list;\n    },\n\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if ((pos == 0 && dow == this_dow) ||\n            (tt.nthWeekDay(dow, pos) == tt.day)) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos);\n        // negative numbers are not false-y\n        return idx !== -1;\n      }\n      return false;\n    },\n\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data &&\n          ruleMapValue == icalrecur_iterator.CONTRACT) {\n\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n      return pass;\n    },\n\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n\n      return (this.check_contract_restriction(\"BYSECOND\", this.last.second) &&\n              this.check_contract_restriction(\"BYMINUTE\", this.last.minute) &&\n              this.check_contract_restriction(\"BYHOUR\", this.last.hour) &&\n              this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) &&\n              this.check_contract_restriction(\"BYWEEKNO\", weekNo) &&\n              this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) &&\n              this.check_contract_restriction(\"BYMONTH\", this.last.month) &&\n              this.check_contract_restriction(\"BYYEARDAY\", doy));\n    },\n\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n      return deftime;\n    },\n\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var result = Object.create(null);\n\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n\n      return result;\n    }\n  };\n\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n\n  return icalrecur_iterator;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurExpansion = (function() {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') ||\n           comp.hasProperty('rrule') ||\n           comp.hasProperty('recurrence-id');\n  }\n\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function(options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function(item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof(options.complete) !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function() {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error(\n            'max tries have occured, rule may be impossible to forfill.'\n          );\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last);\n\n        // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        }\n\n        // no next rule day or recurrence rule is first.\n        if (!next || (iter && next.compare(iter.last) > 0)) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone();\n          // move to next so we can continue\n          iter.next();\n        }\n\n        // if the ruleDate is still next increment it.\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next;\n\n        // check the negative rules\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          }\n\n          // if the current rule is excluded skip it.\n          if (compare === 0) {\n            this._nextExDay();\n            continue;\n          }\n        }\n\n        //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n        return this.last;\n      }\n    },\n\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function() {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n\n      return result;\n    },\n\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function(component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(\n          result,\n          prop,\n          compareTime\n        );\n\n        // ordered insert\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function(component) {\n      this.ruleIterators = [];\n\n      this.last = this.dtstart.clone();\n\n      // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate');\n\n        // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n        if ((this.ruleDates[0]) &&\n            (this.ruleDates[0].compare(this.dtstart) < 0)) {\n\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(\n            this.ruleDates,\n            this.last,\n            compareTime\n          );\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter);\n\n          // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate');\n        // if we have a .last day we increment the index to beyond it.\n        this.exDateInc = ICAL.helpers.binsearchInsert(\n          this.exDates,\n          this.last,\n          compareTime\n        );\n\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function() {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function() {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function() {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter;\n\n      // loop through each iterator\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last;\n\n        // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n        if (iter.completed) {\n          len--;\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n          iters.splice(iterIdx, 1);\n          continue;\n        }\n\n        // find the most recent possible choice\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      }\n\n      // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n      return chosenIter;\n    }\n  };\n\n  return RecurExpansion;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Event = (function() {\n\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function(obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString();\n\n      // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n      this.exceptions[id] = obj;\n\n      // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n      if (obj.modifiesFuture()) {\n        var item = [\n          obj.recurrenceId.toUnixTime(), id\n        ];\n\n        // we keep them sorted so we can find the nearest\n        // value later on...\n        var idx = ICAL.helpers.binsearchInsert(\n          this.rangeExceptions,\n          item,\n          compareRangeException\n        );\n\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function() {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function(time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(\n        this.rangeExceptions,\n        [utc],\n        compareRangeException\n      );\n\n      idx -= 1;\n\n      // occurs before\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n\n      /* istanbul ignore next: sanity check only */\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function(occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(\n          occurrence\n        );\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId];\n\n          // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n          result.item = exception;\n\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone();\n\n            // zones must be same otherwise subtract may be incorrect.\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n\n          end = start.clone();\n          end.addDuration(exception.duration);\n\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function(startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function() {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function() {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function() {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n      if (!endDate) {\n          var duration = this._firstProp('duration');\n          endDate = this.startDate.clone();\n          if (duration) {\n              endDate.addDuration(duration);\n          } else if (endDate.isDate) {\n              endDate.day += 1;\n          }\n      }\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n      this._setTime('dtend', value);\n    },\n\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n\n    set color(value) {\n      this._setProp('color', value);\n    },\n\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function(propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      }\n\n      // utc and local don't get a tzid\n      if (\n        time.zone === ICAL.Timezone.localTimezone ||\n        time.zone === ICAL.Timezone.utcTimezone\n      ) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n\n    _setProp: function(name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n\n    _firstProp: function(name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function() {\n      return this.component.toString();\n    }\n\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.ComponentParser = (function() {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof(options) === 'undefined') {\n      options = {};\n    }\n\n    var key;\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n\n\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete: /* istanbul ignore next */ function() {},\n\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror: /* istanbul ignore next */ function(err) {},\n\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function(ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof(ical) === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n            break;\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n            break;\n          default:\n            continue;\n        }\n      }\n\n      //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n      this.oncomplete();\n    }\n  };\n\n  return ComponentParser;\n}());\n"]},"metadata":{},"sourceType":"script"}