{"ast":null,"code":"'use strict';\n\nmodule.exports = findAndReplace;\n\nvar visit = require('unist-util-visit-parents');\n\nvar convert = require('unist-util-is/convert');\n\nvar escape = require('escape-string-regexp');\n\nvar splice = [].splice;\n\nfunction findAndReplace(tree, find, replace, options) {\n  var settings;\n  var schema;\n\n  if (typeof find === 'string' || find && typeof find.exec === 'function') {\n    schema = [[find, replace]];\n  } else {\n    schema = find;\n    options = replace;\n  }\n\n  settings = options || {};\n  search(tree, settings, handlerFactory(toPairs(schema)));\n  return tree;\n\n  function handlerFactory(pairs) {\n    var pair = pairs[0];\n    return handler;\n\n    function handler(node, parent) {\n      var find = pair[0];\n      var replace = pair[1];\n      var nodes = [];\n      var start = 0;\n      var index = parent.children.indexOf(node);\n      var position;\n      var match;\n      var subhandler;\n      var value;\n      find.lastIndex = 0;\n      match = find.exec(node.value);\n\n      while (match) {\n        position = match.index;\n        value = replace.apply(null, [].concat(match, {\n          index: match.index,\n          input: match.input\n        }));\n\n        if (value !== false) {\n          if (start !== position) {\n            nodes.push({\n              type: 'text',\n              value: node.value.slice(start, position)\n            });\n          }\n\n          if (typeof value === 'string' && value.length > 0) {\n            value = {\n              type: 'text',\n              value: value\n            };\n          }\n\n          if (value) {\n            nodes = [].concat(nodes, value);\n          }\n\n          start = position + match[0].length;\n        }\n\n        if (!find.global) {\n          break;\n        }\n\n        match = find.exec(node.value);\n      }\n\n      if (position === undefined) {\n        nodes = [node];\n        index--;\n      } else {\n        if (start < node.value.length) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start)\n          });\n        }\n\n        nodes.unshift(index, 1);\n        splice.apply(parent.children, nodes);\n      }\n\n      if (pairs.length > 1) {\n        subhandler = handlerFactory(pairs.slice(1));\n        position = -1;\n\n        while (++position < nodes.length) {\n          node = nodes[position];\n\n          if (node.type === 'text') {\n            subhandler(node, parent);\n          } else {\n            search(node, settings, subhandler);\n          }\n        }\n      }\n\n      return index + nodes.length + 1;\n    }\n  }\n}\n\nfunction search(tree, settings, handler) {\n  var ignored = convert(settings.ignore || []);\n  var result = [];\n  visit(tree, 'text', visitor);\n  return result;\n\n  function visitor(node, parents) {\n    var index = -1;\n    var parent;\n    var grandparent;\n\n    while (++index < parents.length) {\n      parent = parents[index];\n\n      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n\n      grandparent = parent;\n    }\n\n    return handler(node, grandparent);\n  }\n}\n\nfunction toPairs(schema) {\n  var result = [];\n  var key;\n  var index;\n\n  if (typeof schema !== 'object') {\n    throw new Error('Expected array or object as schema');\n  }\n\n  if ('length' in schema) {\n    index = -1;\n\n    while (++index < schema.length) {\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\n    }\n  } else {\n    for (key in schema) {\n      result.push([toExpression(key), toFunction(schema[key])]);\n    }\n  }\n\n  return result;\n}\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : returner;\n\n  function returner() {\n    return replace;\n  }\n}","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/mdast-util-find-and-replace/index.js"],"names":["module","exports","findAndReplace","visit","require","convert","escape","splice","tree","find","replace","options","settings","schema","exec","search","handlerFactory","toPairs","pairs","pair","handler","node","parent","nodes","start","index","children","indexOf","position","match","subhandler","value","lastIndex","apply","concat","input","push","type","slice","length","global","undefined","unshift","ignored","ignore","result","visitor","parents","grandparent","key","Error","toExpression","toFunction","RegExp","returner"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = findAndReplace\n\nvar visit = require('unist-util-visit-parents')\nvar convert = require('unist-util-is/convert')\nvar escape = require('escape-string-regexp')\n\nvar splice = [].splice\n\nfunction findAndReplace(tree, find, replace, options) {\n  var settings\n  var schema\n\n  if (typeof find === 'string' || (find && typeof find.exec === 'function')) {\n    schema = [[find, replace]]\n  } else {\n    schema = find\n    options = replace\n  }\n\n  settings = options || {}\n\n  search(tree, settings, handlerFactory(toPairs(schema)))\n\n  return tree\n\n  function handlerFactory(pairs) {\n    var pair = pairs[0]\n\n    return handler\n\n    function handler(node, parent) {\n      var find = pair[0]\n      var replace = pair[1]\n      var nodes = []\n      var start = 0\n      var index = parent.children.indexOf(node)\n      var position\n      var match\n      var subhandler\n      var value\n\n      find.lastIndex = 0\n\n      match = find.exec(node.value)\n\n      while (match) {\n        position = match.index\n        value = replace.apply(\n          null,\n          [].concat(match, {index: match.index, input: match.input})\n        )\n\n        if (value !== false) {\n          if (start !== position) {\n            nodes.push({type: 'text', value: node.value.slice(start, position)})\n          }\n\n          if (typeof value === 'string' && value.length > 0) {\n            value = {type: 'text', value: value}\n          }\n\n          if (value) {\n            nodes = [].concat(nodes, value)\n          }\n\n          start = position + match[0].length\n        }\n\n        if (!find.global) {\n          break\n        }\n\n        match = find.exec(node.value)\n      }\n\n      if (position === undefined) {\n        nodes = [node]\n        index--\n      } else {\n        if (start < node.value.length) {\n          nodes.push({type: 'text', value: node.value.slice(start)})\n        }\n\n        nodes.unshift(index, 1)\n        splice.apply(parent.children, nodes)\n      }\n\n      if (pairs.length > 1) {\n        subhandler = handlerFactory(pairs.slice(1))\n        position = -1\n\n        while (++position < nodes.length) {\n          node = nodes[position]\n\n          if (node.type === 'text') {\n            subhandler(node, parent)\n          } else {\n            search(node, settings, subhandler)\n          }\n        }\n      }\n\n      return index + nodes.length + 1\n    }\n  }\n}\n\nfunction search(tree, settings, handler) {\n  var ignored = convert(settings.ignore || [])\n  var result = []\n\n  visit(tree, 'text', visitor)\n\n  return result\n\n  function visitor(node, parents) {\n    var index = -1\n    var parent\n    var grandparent\n\n    while (++index < parents.length) {\n      parent = parents[index]\n\n      if (\n        ignored(\n          parent,\n          grandparent ? grandparent.children.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    return handler(node, grandparent)\n  }\n}\n\nfunction toPairs(schema) {\n  var result = []\n  var key\n  var index\n\n  if (typeof schema !== 'object') {\n    throw new Error('Expected array or object as schema')\n  }\n\n  if ('length' in schema) {\n    index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    for (key in schema) {\n      result.push([toExpression(key), toFunction(schema[key])])\n    }\n  }\n\n  return result\n}\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : returner\n\n  function returner() {\n    return replace\n  }\n}\n"]},"metadata":{},"sourceType":"script"}