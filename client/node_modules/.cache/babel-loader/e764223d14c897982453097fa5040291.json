{"ast":null,"code":"\"use strict\";\n/**\n * Full blown HTML parsing based on htmlparser2.\n * Pulls in a heavy set of dependencies and thus WILL bloat your bundle size.\n * You have been warned.\n **/\n\nvar React = require('react');\n\nvar xtend = require('xtend');\n\nvar visit = require('unist-util-visit');\n\nvar HtmlToReact = require('html-to-react');\n\nvar symbols = require('../symbols');\n\nvar type = 'parsedHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar startTagRe = /^<([a-z]+)\\b/i;\nvar closingTagRe = /^<\\/([a-z]+)\\s*>$/;\nvar parser = new HtmlToReact.Parser();\nvar processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions(React);\nvar defaultConfig = {\n  isValidNode: function isValidNode(node) {\n    return node.type !== 'script';\n  },\n  processingInstructions: [{\n    shouldProcessNode: function shouldProcessNode() {\n      return true;\n    },\n    processNode: processNodeDefinitions.processDefaultNode\n  }]\n};\n\nfunction parseHtml(config, tree, props) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (!props.allowDangerousHtml && props.escapeHtml !== false) {\n      parent.children.splice(index, 1, {\n        type: 'text',\n        position: node.position,\n        value: node.value\n      });\n      return true;\n    }\n\n    if (props.skipHtml) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosingTagName(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: 'virtualHtml',\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = parseNode(node, config);\n\n    if (!current || current.type === type) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, parsedHtml(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  ); // Find any leftover HTML elements and blindly replace them with a parsed version\n\n  visit(tree, 'html', function (node, index, parent) {\n    var element = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n\n    if (!element) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    parent.children.splice(index, 1, {\n      type: type,\n      element: element,\n      value: node.value,\n      position: node.position\n    });\n    return true;\n  });\n  return tree;\n}\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction parseNode(node, config) {\n  var match = node.value.trim().match(closingTagRe);\n\n  if (match) {\n    return {\n      tag: match[1],\n      opening: false,\n      node: node\n    };\n  }\n\n  var el = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n  /* istanbul ignore if - seems to never happen. Hiding it because we plan on\n   * moving to rehype. */\n\n  if (!el) {\n    return false;\n  }\n\n  var isMultiple = React.Children.count(el) > 1;\n  var isSelfClosing = !isMultiple && selfClosingRe.test(\"<\".concat(el.type, \">\"));\n\n  if (isMultiple || isSelfClosing) {\n    return {\n      type: type,\n      position: node.position,\n      node: el\n    };\n  }\n\n  var startTagMatch = node.value.trim().match(startTagRe);\n  /* istanbul ignore next - seems it’s always a start tag, hiding it because we\n   * plan on moving to rehype. */\n\n  var tag = startTagMatch ? startTagMatch[1] : el.type;\n  return {\n    tag: tag,\n    opening: true,\n    node: node,\n    element: el\n  };\n}\n\nfunction getSelfClosingTagName(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction parsedHtml(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    element: fromNode.element,\n    value: fromNode.node.value,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}\n\nmodule.exports = function getHtmlParserPlugin(config, props) {\n  if (props && (typeof config.source !== 'undefined' || typeof config.children !== 'undefined')) {\n    throw new Error('react-markdown: `html-parser` must be called before use - see https://github.com/remarkjs/react-markdown#parsing-html');\n  }\n\n  var htmlConfig = xtend(defaultConfig, config || {});\n  var plugin = parseHtml.bind(null, htmlConfig);\n  plugin.identity = symbols.HtmlParser;\n  return plugin;\n};","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/react-markdown/lib/plugins/html-parser.js"],"names":["React","require","xtend","visit","HtmlToReact","symbols","type","selfClosingRe","startTagRe","closingTagRe","parser","Parser","processNodeDefinitions","ProcessNodeDefinitions","defaultConfig","isValidNode","node","processingInstructions","shouldProcessNode","processNode","processDefaultNode","parseHtml","config","tree","props","open","currentParent","index","parent","allowDangerousHtml","escapeHtml","children","splice","position","value","skipHtml","selfClosing","getSelfClosingTagName","tag","current","parseNode","matching","findAndPull","parsedHtml","opening","push","element","parseWithInstructions","matchingTag","i","length","match","trim","el","isMultiple","Children","count","isSelfClosing","test","concat","startTagMatch","fromNode","toNode","fromIndex","indexOf","toIndex","extracted","slice","start","end","indent","module","exports","getHtmlParserPlugin","source","Error","htmlConfig","plugin","bind","identity","HtmlParser"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Full blown HTML parsing based on htmlparser2.\n * Pulls in a heavy set of dependencies and thus WILL bloat your bundle size.\n * You have been warned.\n **/\nvar React = require('react');\n\nvar xtend = require('xtend');\n\nvar visit = require('unist-util-visit');\n\nvar HtmlToReact = require('html-to-react');\n\nvar symbols = require('../symbols');\n\nvar type = 'parsedHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar startTagRe = /^<([a-z]+)\\b/i;\nvar closingTagRe = /^<\\/([a-z]+)\\s*>$/;\nvar parser = new HtmlToReact.Parser();\nvar processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions(React);\nvar defaultConfig = {\n  isValidNode: function isValidNode(node) {\n    return node.type !== 'script';\n  },\n  processingInstructions: [{\n    shouldProcessNode: function shouldProcessNode() {\n      return true;\n    },\n    processNode: processNodeDefinitions.processDefaultNode\n  }]\n};\n\nfunction parseHtml(config, tree, props) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (!props.allowDangerousHtml && props.escapeHtml !== false) {\n      parent.children.splice(index, 1, {\n        type: 'text',\n        position: node.position,\n        value: node.value\n      });\n      return true;\n    }\n\n    if (props.skipHtml) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosingTagName(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: 'virtualHtml',\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = parseNode(node, config);\n\n    if (!current || current.type === type) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, parsedHtml(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  ); // Find any leftover HTML elements and blindly replace them with a parsed version\n\n  visit(tree, 'html', function (node, index, parent) {\n    var element = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n\n    if (!element) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    parent.children.splice(index, 1, {\n      type: type,\n      element: element,\n      value: node.value,\n      position: node.position\n    });\n    return true;\n  });\n  return tree;\n}\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction parseNode(node, config) {\n  var match = node.value.trim().match(closingTagRe);\n\n  if (match) {\n    return {\n      tag: match[1],\n      opening: false,\n      node: node\n    };\n  }\n\n  var el = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n  /* istanbul ignore if - seems to never happen. Hiding it because we plan on\n   * moving to rehype. */\n\n  if (!el) {\n    return false;\n  }\n\n  var isMultiple = React.Children.count(el) > 1;\n  var isSelfClosing = !isMultiple && selfClosingRe.test(\"<\".concat(el.type, \">\"));\n\n  if (isMultiple || isSelfClosing) {\n    return {\n      type: type,\n      position: node.position,\n      node: el\n    };\n  }\n\n  var startTagMatch = node.value.trim().match(startTagRe);\n  /* istanbul ignore next - seems it’s always a start tag, hiding it because we\n   * plan on moving to rehype. */\n\n  var tag = startTagMatch ? startTagMatch[1] : el.type;\n  return {\n    tag: tag,\n    opening: true,\n    node: node,\n    element: el\n  };\n}\n\nfunction getSelfClosingTagName(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction parsedHtml(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    element: fromNode.element,\n    value: fromNode.node.value,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}\n\nmodule.exports = function getHtmlParserPlugin(config, props) {\n  if (props && (typeof config.source !== 'undefined' || typeof config.children !== 'undefined')) {\n    throw new Error('react-markdown: `html-parser` must be called before use - see https://github.com/remarkjs/react-markdown#parsing-html');\n  }\n\n  var htmlConfig = xtend(defaultConfig, config || {});\n  var plugin = parseHtml.bind(null, htmlConfig);\n  plugin.identity = symbols.HtmlParser;\n  return plugin;\n};"]},"metadata":{},"sourceType":"script"}