{"ast":null,"code":"import { useCallback, useEffect, useRef } from 'react';\nimport { logChatPromiseExecution } from 'stream-chat';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nexport var useMessageInputText = function (props, state, dispatch) {\n  var channel = useChannelStateContext('useMessageInputText').channel;\n  var additionalTextareaProps = props.additionalTextareaProps,\n      focus = props.focus,\n      parent = props.parent,\n      _a = props.publishTypingEvent,\n      publishTypingEvent = _a === void 0 ? true : _a;\n  var text = state.text;\n  var textareaRef = useRef(); // Focus\n\n  useEffect(function () {\n    if (focus && textareaRef.current) {\n      textareaRef.current.focus();\n    }\n  }, [focus]); // Text + cursor position\n\n  var newCursorPosition = useRef();\n  var insertText = useCallback(function (textToInsert) {\n    var maxLength = (additionalTextareaProps || {}).maxLength;\n\n    if (!textareaRef.current) {\n      dispatch({\n        getNewText: function (text) {\n          var updatedText = text + textToInsert;\n\n          if (maxLength && updatedText.length > maxLength) {\n            return updatedText.slice(0, maxLength);\n          }\n\n          return updatedText;\n        },\n        type: 'setText'\n      });\n      return;\n    }\n\n    var _a = textareaRef.current,\n        selectionEnd = _a.selectionEnd,\n        selectionStart = _a.selectionStart;\n    newCursorPosition.current = selectionStart + textToInsert.length;\n    dispatch({\n      getNewText: function (prevText) {\n        var updatedText = prevText.slice(0, selectionStart) + textToInsert + prevText.slice(selectionEnd);\n\n        if (maxLength && updatedText.length > maxLength) {\n          return updatedText.slice(0, maxLength);\n        }\n\n        return updatedText;\n      },\n      type: 'setText'\n    });\n  }, [additionalTextareaProps, newCursorPosition, textareaRef]);\n  useEffect(function () {\n    var textareaElement = textareaRef.current;\n\n    if (textareaElement && newCursorPosition.current !== undefined) {\n      textareaElement.selectionStart = newCursorPosition.current;\n      textareaElement.selectionEnd = newCursorPosition.current;\n      newCursorPosition.current = undefined;\n    }\n  }, [text, newCursorPosition]);\n  var handleChange = useCallback(function (event) {\n    event.preventDefault();\n\n    if (!event || !event.target) {\n      return;\n    }\n\n    var newText = event.target.value;\n    dispatch({\n      getNewText: function () {\n        return newText;\n      },\n      type: 'setText'\n    });\n\n    if (publishTypingEvent && newText && channel) {\n      logChatPromiseExecution(channel.keystroke(parent === null || parent === void 0 ? void 0 : parent.id), 'start typing event');\n    }\n  }, [channel, parent, publishTypingEvent]);\n  return {\n    handleChange: handleChange,\n    insertText: insertText,\n    textareaRef: textareaRef\n  };\n};","map":{"version":3,"sources":["/Users/pedrohenriquemachado/Documents/Projects/multi-tic-tac-toe/client/node_modules/stream-chat-react/dist/components/MessageInput/hooks/useMessageInputText.js"],"names":["useCallback","useEffect","useRef","logChatPromiseExecution","useChannelStateContext","useMessageInputText","props","state","dispatch","channel","additionalTextareaProps","focus","parent","_a","publishTypingEvent","text","textareaRef","current","newCursorPosition","insertText","textToInsert","maxLength","getNewText","updatedText","length","slice","type","selectionEnd","selectionStart","prevText","textareaElement","undefined","handleChange","event","preventDefault","target","newText","value","keystroke","id"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { logChatPromiseExecution } from 'stream-chat';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nexport var useMessageInputText = function (props, state, dispatch) {\n    var channel = useChannelStateContext('useMessageInputText').channel;\n    var additionalTextareaProps = props.additionalTextareaProps, focus = props.focus, parent = props.parent, _a = props.publishTypingEvent, publishTypingEvent = _a === void 0 ? true : _a;\n    var text = state.text;\n    var textareaRef = useRef();\n    // Focus\n    useEffect(function () {\n        if (focus && textareaRef.current) {\n            textareaRef.current.focus();\n        }\n    }, [focus]);\n    // Text + cursor position\n    var newCursorPosition = useRef();\n    var insertText = useCallback(function (textToInsert) {\n        var maxLength = (additionalTextareaProps || {}).maxLength;\n        if (!textareaRef.current) {\n            dispatch({\n                getNewText: function (text) {\n                    var updatedText = text + textToInsert;\n                    if (maxLength && updatedText.length > maxLength) {\n                        return updatedText.slice(0, maxLength);\n                    }\n                    return updatedText;\n                },\n                type: 'setText',\n            });\n            return;\n        }\n        var _a = textareaRef.current, selectionEnd = _a.selectionEnd, selectionStart = _a.selectionStart;\n        newCursorPosition.current = selectionStart + textToInsert.length;\n        dispatch({\n            getNewText: function (prevText) {\n                var updatedText = prevText.slice(0, selectionStart) + textToInsert + prevText.slice(selectionEnd);\n                if (maxLength && updatedText.length > maxLength) {\n                    return updatedText.slice(0, maxLength);\n                }\n                return updatedText;\n            },\n            type: 'setText',\n        });\n    }, [additionalTextareaProps, newCursorPosition, textareaRef]);\n    useEffect(function () {\n        var textareaElement = textareaRef.current;\n        if (textareaElement && newCursorPosition.current !== undefined) {\n            textareaElement.selectionStart = newCursorPosition.current;\n            textareaElement.selectionEnd = newCursorPosition.current;\n            newCursorPosition.current = undefined;\n        }\n    }, [text, newCursorPosition]);\n    var handleChange = useCallback(function (event) {\n        event.preventDefault();\n        if (!event || !event.target) {\n            return;\n        }\n        var newText = event.target.value;\n        dispatch({\n            getNewText: function () { return newText; },\n            type: 'setText',\n        });\n        if (publishTypingEvent && newText && channel) {\n            logChatPromiseExecution(channel.keystroke(parent === null || parent === void 0 ? void 0 : parent.id), 'start typing event');\n        }\n    }, [channel, parent, publishTypingEvent]);\n    return {\n        handleChange: handleChange,\n        insertText: insertText,\n        textareaRef: textareaRef,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}